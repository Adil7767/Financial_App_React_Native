"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _native = _interopRequireDefault(require("styled-components/native"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _templateObject2() {
  const data = _taggedTemplateLiteral(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    align-items: center;\n    justify-content: center;\n"]);

  _templateObject2 = function () {
    return data;
  };

  return data;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n    overflow: hidden;\n    align-items: center;\n    justify-content: center;\n"]);

  _templateObject = function () {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

const ParallaxContainer = _native.default.View(_templateObject());

const ParallaxLoaderContainer = _native.default.View(_templateObject2());

class ParallaxImage extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      offset: 0,
      width: 0,
      height: 0,
      status: 1,
      // 1 -> loading; 2 -> loaded // 3 -> transition finished; 4 -> error
      animOpacity: new _reactNative.Animated.Value(0)
    });

    _defineProperty(this, "_container", void 0);

    _defineProperty(this, "_mounted", void 0);

    this._onLoad = this._onLoad.bind(this);
    this._onError = this._onError.bind(this);
    this._measureLayout = this._measureLayout.bind(this);
  }

  setNativeProps(nativeProps) {
    this._container.setNativeProps(nativeProps);
  }

  componentDidMount() {
    this._mounted = true;
    setTimeout(() => {
      this._measureLayout();
    }, 0);
  }

  componentWillUnmount() {
    this._mounted = false;
  }

  _measureLayout() {
    if (this._container) {
      const {
        dimensions,
        vertical,
        carouselRef,
        sliderWidth,
        sliderHeight,
        itemWidth,
        itemHeight
      } = this.props;

      if (carouselRef) {
        this._container.measureLayout( // @ts-ignore
        (0, _reactNative.findNodeHandle)(carouselRef), (x, y, width, height, pageX, pageY) => {
          const offset = vertical ? y - (sliderHeight - itemHeight) / 2 : x - (sliderWidth - itemWidth) / 2;
          this.setState({
            offset: offset,
            width: dimensions && dimensions.width ? dimensions.width : Math.ceil(width),
            height: dimensions && dimensions.height ? dimensions.height : Math.ceil(height)
          });
        });
      }
    }
  }

  _onLoad(event) {
    const {
      animOpacity
    } = this.state;
    const {
      fadeDuration,
      onLoad
    } = this.props;

    if (!this._mounted) {
      return;
    }

    this.setState({
      status: 2
    });

    if (onLoad) {
      onLoad(event);
    }

    _reactNative.Animated.timing(animOpacity, {
      toValue: 1,
      duration: fadeDuration,
      easing: _reactNative.Easing.out(_reactNative.Easing.quad),
      isInteraction: false,
      useNativeDriver: true
    }).start(() => {
      this.setState({
        status: 3
      });
    });
  } // If arg is missing from method signature, it just won't be called


  _onError(event) {
    const {
      onError
    } = this.props;
    this.setState({
      status: 4
    });

    if (onError) {
      onError(event);
    }
  }

  get image() {
    const {
      status,
      animOpacity,
      offset,
      width,
      height
    } = this.state;
    const {
      scrollPosition,
      vertical,
      sliderWidth,
      sliderHeight,
      parallaxFactor,
      AnimatedImageComponent,
      ...other
    } = this.props;
    const parallaxPadding = (vertical ? height : width) * parallaxFactor;
    const requiredStyles = {
      position: "relative"
    };
    const dynamicStyles = {
      width: vertical ? width : width + parallaxPadding * 2,
      height: vertical ? height + parallaxPadding * 2 : height,
      opacity: animOpacity,
      transform: scrollPosition ? [{
        translateX: !vertical // @ts-ignore
        ? scrollPosition.interpolate({
          inputRange: [offset - sliderWidth, offset + sliderWidth],
          outputRange: [-parallaxPadding, parallaxPadding],
          extrapolate: "clamp"
        }) : 0
      }, {
        translateY: vertical // @ts-ignore
        ? scrollPosition.interpolate({
          inputRange: [offset - sliderHeight, offset + sliderHeight],
          outputRange: [-parallaxPadding, parallaxPadding],
          extrapolate: "clamp"
        }) : 0
      }] : []
    };
    return (
      /*#__PURE__*/
      // @ts-ignore
      React.createElement(AnimatedImageComponent, _extends({}, other, {
        style: [{
          position: "relative",
          resizeMode: "cover",
          width: null,
          height: null
        }, requiredStyles, dynamicStyles],
        onLoad: this._onLoad,
        onError: status !== 3 ? this._onError : undefined // prevent infinite-loop bug

      }))
    );
  }

  get spinner() {
    const {
      status
    } = this.state;
    const {
      showSpinner,
      spinnerColor
    } = this.props;
    return status === 1 && showSpinner ? /*#__PURE__*/React.createElement(ParallaxLoaderContainer, null, /*#__PURE__*/React.createElement(_reactNative.ActivityIndicator, {
      size: "small",
      color: spinnerColor,
      animating: true
    })) : false;
  }

  render() {
    return /*#__PURE__*/React.createElement(ParallaxContainer, {
      ref: c => {
        this._container = c;
      },
      pointerEvents: "none",
      onLayout: this._measureLayout
    }, this.image, this.spinner);
  }

}

exports.default = ParallaxImage;

_defineProperty(ParallaxImage, "defaultProps", {
  containerStyle: {},
  fadeDuration: 500,
  parallaxFactor: 0.3,
  showSpinner: true,
  spinnerColor: "rgba(0, 0, 0, 0.4)",
  AnimatedImageComponent: _reactNative.Animated.Image
});
//# sourceMappingURL=ParallaxImage.js.map