{"version":3,"sources":["InputLabel.tsx"],"names":["InputLabel","props","parentState","labelBackground","label","error","onLayoutAnimatedText","hasActiveOutline","activeColor","placeholderStyle","baseLabelTranslateX","baseLabelTranslateY","font","fontSize","fontWeight","placeholderOpacity","wiggleOffsetX","labelScale","topPosition","paddingOffset","placeholderColor","errorColor","labelTranslationXOffset","labelProps","labelTranslationX","transform","translateX","labeled","interpolate","inputRange","outputRange","labelStyle","value","translateY","scale","StyleSheet","absoluteFill","opacity","focused","labelLayout","measured","top","color"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport { Animated, StyleSheet } from \"react-native\";\r\nimport AnimatedText from \"../../Text/AnimatedText\";\r\n\r\nimport type { InputLabelProps } from \"../types\";\r\n\r\nconst InputLabel = (props: InputLabelProps) => {\r\n    const { parentState, labelBackground } = props;\r\n\r\n    const {\r\n        label,\r\n        error,\r\n        onLayoutAnimatedText,\r\n        hasActiveOutline,\r\n        activeColor,\r\n        placeholderStyle,\r\n        baseLabelTranslateX,\r\n        baseLabelTranslateY,\r\n        font,\r\n        fontSize,\r\n        fontWeight,\r\n        placeholderOpacity,\r\n        wiggleOffsetX,\r\n        labelScale,\r\n        topPosition,\r\n        paddingOffset,\r\n        placeholderColor,\r\n        errorColor,\r\n        labelTranslationXOffset,\r\n    } = props.labelProps;\r\n\r\n    const labelTranslationX = {\r\n        transform: [\r\n            {\r\n                // Offset label scale since RN doesn't support transform origin\r\n                translateX: parentState.labeled.interpolate({\r\n                    inputRange: [0, 1],\r\n                    outputRange: [baseLabelTranslateX, labelTranslationXOffset || 0],\r\n                }),\r\n            },\r\n        ],\r\n    };\r\n\r\n    const labelStyle = {\r\n        ...font,\r\n        fontSize,\r\n        fontWeight,\r\n        transform: [\r\n            {\r\n                // Wiggle the label when there's an error\r\n                translateX: parentState.error.interpolate({\r\n                    inputRange: [0, 0.5, 1],\r\n                    outputRange: [0, parentState.value && error ? wiggleOffsetX : 0, 0],\r\n                }),\r\n            },\r\n            {\r\n                // Move label to top\r\n                translateY: parentState.labeled.interpolate({\r\n                    inputRange: [0, 1],\r\n                    outputRange: [baseLabelTranslateY, 0],\r\n                }),\r\n            },\r\n            {\r\n                // Make label smaller\r\n                scale: parentState.labeled.interpolate({\r\n                    inputRange: [0, 1],\r\n                    outputRange: [labelScale, 1],\r\n                }),\r\n            },\r\n        ],\r\n    };\r\n\r\n    return label ? (\r\n        // Position colored placeholder and gray placeholder on top of each other and crossfade them\r\n        // This gives the effect of animating the color, but allows us to use native driver\r\n        <Animated.View\r\n            pointerEvents=\"none\"\r\n            style={[\r\n                StyleSheet.absoluteFill,\r\n                {\r\n                    opacity:\r\n                        // Hide the label in minimized state until we measure it's width\r\n                        parentState.value || parentState.focused\r\n                            ? parentState.labelLayout.measured\r\n                                ? 1\r\n                                : 0\r\n                            : 1,\r\n                },\r\n                labelTranslationX,\r\n            ]}\r\n        >\r\n            {labelBackground?.({\r\n                parentState,\r\n                labelStyle,\r\n                labelProps: props.labelProps,\r\n            })}\r\n            <AnimatedText\r\n                onLayout={onLayoutAnimatedText}\r\n                style={[\r\n                    placeholderStyle,\r\n                    {\r\n                        top: topPosition,\r\n                    },\r\n                    labelStyle,\r\n                    paddingOffset || {},\r\n                    {\r\n                        color: activeColor,\r\n                        opacity: parentState.labeled.interpolate({\r\n                            inputRange: [0, 1],\r\n                            outputRange: [hasActiveOutline ? 1 : 0, 0],\r\n                        }),\r\n                    },\r\n                ]}\r\n                numberOfLines={1}\r\n            >\r\n                {label}\r\n            </AnimatedText>\r\n            <AnimatedText\r\n                style={[\r\n                    placeholderStyle,\r\n                    {\r\n                        top: topPosition,\r\n                    },\r\n                    labelStyle,\r\n                    paddingOffset,\r\n                    {\r\n                        color: error && errorColor ? errorColor : placeholderColor,\r\n                        opacity: placeholderOpacity,\r\n                    },\r\n                ]}\r\n                numberOfLines={1}\r\n            >\r\n                {label}\r\n            </AnimatedText>\r\n        </Animated.View>\r\n    ) : null;\r\n};\r\n\r\nexport default InputLabel;\r\n"]}