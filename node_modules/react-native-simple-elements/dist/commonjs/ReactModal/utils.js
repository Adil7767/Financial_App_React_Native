"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reversePercentage = exports.buildAnimations = exports.makeSlideTranslation = void 0;

var animatable = _interopRequireWildcard(require("react-native-animatable"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { Dimensions } from "react-native";
// const { height, width } = Dimensions.get("window");
// export const initializeAnimations = () => {
//     // Since react-native-animatable applies by default a margin of 100 to its
//     // sliding animation, we reset them here overriding the margin to 0.
//     const animationDefinitions: Record<string, CustomAnimation> = {
//         slideInDown: makeSlideTranslation("translateY", -height, 0),
//         slideInUp: makeSlideTranslation("translateY", height, 0),
//         slideInLeft: makeSlideTranslation("translateX", -width, 0),
//         slideInRight: makeSlideTranslation("translateX", width, 0),
//         slideOutDown: makeSlideTranslation("translateY", 0, height),
//         slideOutUp: makeSlideTranslation("translateY", 0, -height),
//         slideOutLeft: makeSlideTranslation("translateX", 0, -width),
//         slideOutRight: makeSlideTranslation("translateX", 0, width),
//     };
//     animatable.initializeRegistryWithDefinitions(animationDefinitions);
// };
const makeSlideTranslation = (translationType, fromValue, toValue) => ({
  from: {
    [translationType]: fromValue
  },
  to: {
    [translationType]: toValue
  }
}); // User can define custom react-native-animatable animations, see PR #72
// Utility for creating our own custom react-native-animatable animations


exports.makeSlideTranslation = makeSlideTranslation;

const buildAnimations = ({
  animationIn,
  animationOut
}) => {
  let updatedAnimationIn;
  let updatedAnimationOut;

  if (isObject(animationIn)) {
    const animationName = JSON.stringify(animationIn);
    makeAnimation(animationName, animationIn);
    updatedAnimationIn = animationName;
  } else {
    updatedAnimationIn = animationIn;
  }

  if (isObject(animationOut)) {
    const animationName = JSON.stringify(animationOut);
    makeAnimation(animationName, animationOut);
    updatedAnimationOut = animationName;
  } else {
    updatedAnimationOut = animationOut;
  }

  return {
    animationIn: updatedAnimationIn,
    animationOut: updatedAnimationOut
  };
};

exports.buildAnimations = buildAnimations;

const reversePercentage = x => -(x - 1);

exports.reversePercentage = reversePercentage;

const makeAnimation = (name, obj) => {
  animatable.registerAnimation(name, animatable.createAnimation(obj));
};

const isObject = obj => {
  return obj !== null && typeof obj === "object";
};
//# sourceMappingURL=utils.js.map