"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Toast = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactNativeIphoneXHelper = require("react-native-iphone-x-helper");

var _account = _interopRequireDefault(require("@mdi/svg/svg/account.svg"));

var _Box = _interopRequireDefault(require("../Box"));

var _Icon = require("../../Icon");

var _styles = require("./styles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const statusBarHeight = (0, _reactNativeIphoneXHelper.getStatusBarHeight)();
const offset = statusBarHeight + 16;
const shadow = {
  shadowColor: "#000",
  shadowOffset: {
    width: 0,
    height: 0
  },
  shadowOpacity: 0.1,
  shadowRadius: 2,
  elevation: 1
};
const DEFAULT_PROPS = {
  duration: 3000,
  intent: "SUCCESS",
  onPress: () => false,
  shouldVibrate: false,
  closeIconColor: "text",
  message: "Toast message!",
  hideIcon: false,
  toastStyles: {
    borderColor: "black",
    bg: "background"
  },
  closeButtonStyles: {
    p: 2,
    mx: 2,
    bg: "black",
    borderRadius: 4,
    alignItems: "center"
  }
};

const Toast = ({
  accentColor,
  closeIconColor,
  // closeIconFamily,
  // closeIconName,
  closeIconSize,
  color,
  duration,
  hideIcon,
  iconColor,
  // iconFamily,
  iconName,
  id,
  index,
  intent,
  message,
  onClose,
  onPress,
  position,
  shouldVibrate,
  subMessage,
  toastStyles,
  hideAccent,
  closeButtonStyles
}) => {
  const isSuccess = intent === "SUCCESS";
  const isInfo = intent === "INFO";
  const topOffset = offset + 60 * (index || 0);
  const animation = React.useRef(new _reactNative.Animated.Value(0)).current;
  React.useEffect(() => {
    _reactNative.Animated.timing(animation, {
      toValue: 0.5,
      duration: 300,
      useNativeDriver: true
    }).start(() => {
      if (duration !== 0) {
        const timer = setTimeout(() => {
          if (index === 0) {
            clearTimeout(timer);
          }

          id && onClose && onClose(id);
        }, duration);
      }
    });

    if (shouldVibrate) {
      _reactNative.Vibration.vibrate(10);
    }
  }, []);
  const translateY = animation.interpolate({
    inputRange: [0, 0.5],
    outputRange: [position === "BOTTOM" ? topOffset : -topOffset, 0]
  });
  const scale = animation.interpolate({
    inputRange: [0, 0.5],
    outputRange: [0.8, 1],
    extrapolate: "clamp"
  });
  return /*#__PURE__*/React.createElement(_styles.StyledToast, _extends({
    onPress: () => {
      onPress && onPress();
      onClose && id && onClose(id);
    },
    style: {
      transform: [{
        translateY
      }, {
        scale
      }],
      ...shadow
    }
  }, toastStyles, {
    pr: subMessage ? 2 : 0
  }), !hideAccent && /*#__PURE__*/React.createElement(_styles.Accent, {
    testID: "toast-accent",
    bg: accentColor ? accentColor : isSuccess ? "success" : isInfo ? "info" : "error"
  }), !hideIcon && /*#__PURE__*/React.createElement(_styles.IconCont, {
    px: 4
  }, /*#__PURE__*/React.createElement(_Icon.SvgIcon, {
    icon: iconName ? iconName : isSuccess ? _account.default : isInfo ? _account.default : _account.default,
    size: 20,
    color: iconColor ? iconColor : isSuccess ? "success" : isInfo ? "info" : "error" // family={iconFamily || 'Feather'}
    // name={!!iconName ? iconName : isSuccess ? CheckCircleIcon : isInfo ? AlertCircleIcon : XCircleIcon}

  })), /*#__PURE__*/React.createElement(_Box.default, {
    alignItems: "flex-start",
    flex: "1 1 auto",
    pl: hideIcon ? 4 : 0,
    pr: subMessage ? 2 : 0,
    py: 2
  }, /*#__PURE__*/React.createElement(_Box.default, {
    flexDirection: "row",
    flexWrap: "wrap",
    flex: "1 1 auto"
  }, /*#__PURE__*/React.createElement(_styles.Heading, {
    color: color
  }, message)), !!subMessage && /*#__PURE__*/React.createElement(_styles.SubText, {
    color: color,
    mt: 1
  }, subMessage)), /*#__PURE__*/React.createElement(_reactNative.TouchableOpacity, {
    onPress: () => onClose && id && onClose(id)
  }, /*#__PURE__*/React.createElement(_Box.default, Object.assign({}, DEFAULT_PROPS.closeButtonStyles, closeButtonStyles), /*#__PURE__*/React.createElement(_Icon.SvgIcon, {
    icon: _account.default,
    size: closeIconSize || 20,
    color: closeIconColor // family={closeIconFamily || 'Feather'}
    // name={closeIconName || 'x'}

  }))));
};

exports.Toast = Toast;

var _default = /*#__PURE__*/React.memo(Toast);

exports.default = _default;
Toast.defaultProps = DEFAULT_PROPS;
//# sourceMappingURL=index.js.map