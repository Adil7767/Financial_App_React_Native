function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import * as React from "react";
import { Animated, DeviceEventEmitter, Dimensions, InteractionManager, KeyboardAvoidingView, Modal, PanResponder, Platform, TouchableWithoutFeedback, View } from "react-native";
import * as animatable from "react-native-animatable";
import { // initializeAnimations,
buildAnimations, reversePercentage } from "./utils";
import styles from "./modal.style";

const extractAnimationFromProps = props => ({
  animationIn: props.animationIn,
  animationOut: props.animationOut
});

export class ReactNativeModal extends React.Component {
  // We use an internal state for keeping track of the modal visibility: this allows us to keep
  // the modal visible during the exit animation, even if the user has already change the
  // isVisible prop to false.
  // We store in the state the device width and height so that we can update the modal on
  // device rotation.
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      showContent: true,
      isVisible: false,
      deviceWidth: Dimensions.get("screen").width,
      deviceHeight: Dimensions.get("screen").height,
      isSwipeable: !!this.props.swipeDirection,
      pan: null
    });

    _defineProperty(this, "isTransitioning", false);

    _defineProperty(this, "inSwipeClosingState", false);

    _defineProperty(this, "currentSwipingDirection", null);

    _defineProperty(this, "animationIn", void 0);

    _defineProperty(this, "animationOut", void 0);

    _defineProperty(this, "backdropRef", void 0);

    _defineProperty(this, "contentRef", void 0);

    _defineProperty(this, "panResponder", null);

    _defineProperty(this, "getDeviceHeight", () => this.props.deviceHeight || this.state.deviceHeight);

    _defineProperty(this, "getDeviceWidth", () => this.props.deviceWidth || this.state.deviceWidth);

    _defineProperty(this, "buildPanResponder", () => {
      let animEvt = null;
      this.panResponder = PanResponder.create({
        onMoveShouldSetPanResponder: (evt, gestureState) => {
          // Use propagateSwipe to allow inner content to scroll. See PR:
          // https://github.com/react-native-community/react-native-modal/pull/246
          if (!this.props.propagateSwipe) {
            // The number "4" is just a good tradeoff to make the panResponder
            // work correctly even when the modal has touchable buttons.
            // For reference:
            // https://github.com/react-native-community/react-native-modal/pull/197
            const shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;

            if (shouldSetPanResponder && this.props.onSwipeStart) {
              this.props.onSwipeStart();
            }

            this.currentSwipingDirection = this.getSwipingDirection(gestureState);
            animEvt = this.createAnimationEventForSwipe();
            return shouldSetPanResponder;
          }

          return false;
        },
        onStartShouldSetPanResponder: e => {
          const hasScrollableView = e._dispatchInstances && e._dispatchInstances.some(instance => /scrollview|flatlist/i.test(instance.type));

          if (hasScrollableView && this.props.propagateSwipe && this.props.scrollTo && this.props.scrollOffset > 0) {
            return false; // user needs to be able to scroll content back up
          }

          if (this.props.onSwipeStart) {
            this.props.onSwipeStart();
          } // Cleared so that onPanResponderMove can wait to have some delta
          // to work with


          this.currentSwipingDirection = null;
          return true;
        },
        onPanResponderMove: (evt, gestureState) => {
          // Using onStartShouldSetPanResponder we don't have any delta so we don't know
          // The direction to which the user is swiping until some move have been done
          if (!this.currentSwipingDirection) {
            if (gestureState.dx === 0 && gestureState.dy === 0) {
              return;
            }

            this.currentSwipingDirection = this.getSwipingDirection(gestureState);
            animEvt = this.createAnimationEventForSwipe();
          }

          if (this.isSwipeDirectionAllowed(gestureState)) {
            // Dim the background while swiping the modal
            const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);
            this.backdropRef && this.backdropRef.transitionTo({
              opacity: this.props.backdropOpacity * newOpacityFactor
            });

            if (typeof animEvt === "function") {
              animEvt(evt, gestureState);
            }

            if (this.props.onSwipeMove) {
              this.props.onSwipeMove(newOpacityFactor);
            }
          } else {
            if (this.props.scrollTo) {
              if (this.props.scrollHorizontal) {
                let offsetX = -gestureState.dx;

                if (offsetX > this.props.scrollOffsetMax) {
                  offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;
                }

                this.props.scrollTo({
                  x: offsetX,
                  animated: false
                });
              } else {
                let offsetY = -gestureState.dy;

                if (offsetY > this.props.scrollOffsetMax) {
                  offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;
                }

                this.props.scrollTo({
                  y: offsetY,
                  animated: false
                });
              }
            }
          }
        },
        onPanResponderRelease: (evt, gestureState) => {
          // Call the onSwipe prop if the threshold has been exceeded on the right direction
          const accDistance = this.getAccDistancePerDirection(gestureState);

          if (accDistance > this.props.swipeThreshold && this.isSwipeDirectionAllowed(gestureState)) {
            if (this.props.onSwipeComplete) {
              this.inSwipeClosingState = true;
              this.props.onSwipeComplete({
                swipingDirection: this.getSwipingDirection(gestureState)
              });
              return;
            } // Deprecated. Remove later.


            if (this.props.onSwipe) {
              this.inSwipeClosingState = true;
              this.props.onSwipe();
              return;
            }
          } //Reset backdrop opacity and modal position


          if (this.props.onSwipeCancel) {
            this.props.onSwipeCancel();
          }

          if (this.backdropRef) {
            this.backdropRef.transitionTo({
              opacity: this.props.backdropOpacity
            });
          } // Animated.spring(this.state.pan!, {


          Animated.spring(this.state.pan, {
            toValue: {
              x: 0,
              y: 0
            },
            bounciness: 0,
            useNativeDriver: false
          }).start();

          if (this.props.scrollTo) {
            // if (this.props.scrollOffset > this.props.scrollOffsetMax!) {
            if (this.props.scrollOffset > this.props.scrollOffsetMax) {
              this.props.scrollTo({
                y: this.props.scrollOffsetMax,
                animated: true
              });
            }
          }
        }
      });
    });

    _defineProperty(this, "getAccDistancePerDirection", gestureState => {
      switch (this.currentSwipingDirection) {
        case "up":
          return -gestureState.dy;

        case "down":
          return gestureState.dy;

        case "right":
          return gestureState.dx;

        case "left":
          return -gestureState.dx;

        default:
          return 0;
      }
    });

    _defineProperty(this, "getSwipingDirection", gestureState => {
      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {
        return gestureState.dx > 0 ? "right" : "left";
      }

      return gestureState.dy > 0 ? "down" : "up";
    });

    _defineProperty(this, "calcDistancePercentage", gestureState => {
      switch (this.currentSwipingDirection) {
        case "down":
          return (gestureState.moveY - gestureState.y0) / ((this.props.deviceHeight || this.state.deviceHeight) - gestureState.y0);

        case "up":
          return reversePercentage(gestureState.moveY / gestureState.y0);

        case "left":
          return reversePercentage(gestureState.moveX / gestureState.x0);

        case "right":
          return (gestureState.moveX - gestureState.x0) / ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0);

        default:
          return 0;
      }
    });

    _defineProperty(this, "createAnimationEventForSwipe", () => {
      if (this.currentSwipingDirection === "right" || this.currentSwipingDirection === "left") {
        var _this$state$pan;

        return Animated.event([null, {
          dx: (_this$state$pan = this.state.pan) === null || _this$state$pan === void 0 ? void 0 : _this$state$pan.x
        }], {
          useNativeDriver: false
        });
      } else {
        var _this$state$pan2;

        return Animated.event([null, {
          dy: (_this$state$pan2 = this.state.pan) === null || _this$state$pan2 === void 0 ? void 0 : _this$state$pan2.y
        }], {
          useNativeDriver: false
        });
      }
    });

    _defineProperty(this, "isDirectionIncluded", direction => {
      return Array.isArray(this.props.swipeDirection) ? this.props.swipeDirection.includes(direction) : this.props.swipeDirection === direction;
    });

    _defineProperty(this, "isSwipeDirectionAllowed", ({
      dy,
      dx
    }) => {
      const draggedDown = dy > 0;
      const draggedUp = dy < 0;
      const draggedLeft = dx < 0;
      const draggedRight = dx > 0;

      if (this.currentSwipingDirection === "up" && this.isDirectionIncluded("up") && draggedUp) {
        return true;
      } else if (this.currentSwipingDirection === "down" && this.isDirectionIncluded("down") && draggedDown) {
        return true;
      } else if (this.currentSwipingDirection === "right" && this.isDirectionIncluded("right") && draggedRight) {
        return true;
      } else if (this.currentSwipingDirection === "left" && this.isDirectionIncluded("left") && draggedLeft) {
        return true;
      }

      return false;
    });

    _defineProperty(this, "handleDimensionsUpdate", () => {
      if (!this.props.deviceHeight && !this.props.deviceWidth) {
        // Here we update the device dimensions in the state if the layout changed
        // (triggering a render)
        const deviceWidth = Dimensions.get("screen").width;
        const deviceHeight = Dimensions.get("screen").height;

        if (deviceWidth !== this.state.deviceWidth || deviceHeight !== this.state.deviceHeight) {
          this.setState({
            deviceWidth,
            deviceHeight
          });
        }
      }
    });

    _defineProperty(this, "open", () => {
      if (this.isTransitioning) {
        return;
      }

      this.isTransitioning = true;

      if (this.backdropRef) {
        this.backdropRef.transitionTo({
          opacity: this.props.backdropOpacity
        }, this.props.backdropTransitionInTiming);
      } // This is for resetting the pan position,otherwise the modal gets stuck
      // at the last released position when you try to open it.
      // TODO: Could certainly be improved - no idea for the moment.


      if (this.state.isSwipeable) {
        var _this$state$pan3;

        (_this$state$pan3 = this.state.pan) === null || _this$state$pan3 === void 0 ? void 0 : _this$state$pan3.setValue({
          x: 0,
          y: 0
        });
      }

      if (this.contentRef) {
        this.props.onModalWillShow && this.props.onModalWillShow();
        const interactionHandle = InteractionManager.createInteractionHandle();
        this.contentRef.animate(this.animationIn, this.props.animationInTiming).then(() => {
          this.isTransitioning = false;
          InteractionManager.clearInteractionHandle(interactionHandle);

          if (!this.props.isVisible) {
            this.close();
          } else {
            this.props.onModalShow();
          }
        });
      }
    });

    _defineProperty(this, "close", () => {
      if (this.isTransitioning) {
        return;
      }

      this.isTransitioning = true;

      if (this.backdropRef) {
        this.backdropRef.transitionTo({
          opacity: 0
        }, this.props.backdropTransitionOutTiming);
      }

      let animationOut = this.animationOut;

      if (this.inSwipeClosingState) {
        this.inSwipeClosingState = false;

        if (this.currentSwipingDirection === "up") {
          animationOut = "slideOutUp";
        } else if (this.currentSwipingDirection === "down") {
          animationOut = "slideOutDown";
        } else if (this.currentSwipingDirection === "right") {
          animationOut = "slideOutRight";
        } else if (this.currentSwipingDirection === "left") {
          animationOut = "slideOutLeft";
        }
      }

      if (this.contentRef) {
        this.props.onModalWillHide && this.props.onModalWillHide();
        const interactionHandle = InteractionManager.createInteractionHandle();
        this.contentRef.animate(animationOut, this.props.animationOutTiming).then(() => {
          this.isTransitioning = false;
          InteractionManager.clearInteractionHandle(interactionHandle);

          if (this.props.isVisible) {
            this.open();
          } else {
            this.setState({
              showContent: false
            }, () => {
              this.setState({
                isVisible: false
              }, () => {
                this.props.onModalHide();
              });
            });
          }
        });
      }
    });

    _defineProperty(this, "makeBackdrop", () => {
      if (!this.props.hasBackdrop) {
        return null;
      }

      if (this.props.customBackdrop && ! /*#__PURE__*/React.isValidElement(this.props.customBackdrop)) {
        console.warn("Invalid customBackdrop element passed to Modal. You must provide a valid React element.");
      }

      const {
        customBackdrop,
        backdropColor,
        useNativeDriver,
        useNativeDriverForBackdrop,
        onBackdropPress
      } = this.props;
      const hasCustomBackdrop = !!this.props.customBackdrop;
      const backdropComputedStyle = [{
        width: this.getDeviceWidth(),
        height: this.getDeviceHeight(),
        backgroundColor: this.state.showContent && !hasCustomBackdrop ? backdropColor : "transparent"
      }];
      const backdropWrapper = /*#__PURE__*/React.createElement(animatable.View, {
        ref: ref => this.backdropRef = ref,
        useNativeDriver: useNativeDriverForBackdrop !== undefined ? useNativeDriverForBackdrop : useNativeDriver,
        style: [styles.backdrop, backdropComputedStyle]
      }, hasCustomBackdrop && customBackdrop);

      if (hasCustomBackdrop) {
        // The user will handle backdrop presses himself
        return backdropWrapper;
      } // If there's no custom backdrop, handle presses with
      // TouchableWithoutFeedback


      return /*#__PURE__*/React.createElement(TouchableWithoutFeedback, {
        onPress: onBackdropPress
      }, backdropWrapper);
    });

    const {
      animationIn,
      animationOut: _animationOut
    } = buildAnimations(extractAnimationFromProps(props));
    this.animationIn = animationIn;
    this.animationOut = _animationOut;

    if (this.state.isSwipeable) {
      this.state = { ...this.state,
        pan: new Animated.ValueXY()
      };
      this.buildPanResponder();
    }

    if (props.isVisible) {
      this.state = { ...this.state,
        isVisible: true,
        showContent: true
      };
    }
  }

  static getDerivedStateFromProps(nextProps, state) {
    if (!state.isVisible && nextProps.isVisible) {
      return {
        isVisible: true,
        showContent: true
      };
    }

    return null;
  }

  componentDidMount() {
    // Show deprecation message
    if (this.props.onSwipe) {
      console.warn("`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.");
    }

    DeviceEventEmitter.addListener("didUpdateDimensions", this.handleDimensionsUpdate);

    if (this.state.isVisible) {
      this.open();
    }
  }

  componentWillUnmount() {
    DeviceEventEmitter.removeListener("didUpdateDimensions", this.handleDimensionsUpdate);
  }

  componentDidUpdate(prevProps) {
    // If the animations have been changed then rebuild them to make sure we're
    // using the most up-to-date ones
    if (this.props.animationIn !== prevProps.animationIn || this.props.animationOut !== prevProps.animationOut) {
      const {
        animationIn,
        animationOut
      } = buildAnimations(extractAnimationFromProps(this.props));
      this.animationIn = animationIn;
      this.animationOut = animationOut;
    } // If backdrop opacity has been changed then make sure to update it


    if (this.props.backdropOpacity !== prevProps.backdropOpacity && this.backdropRef) {
      this.backdropRef.transitionTo({
        opacity: this.props.backdropOpacity
      }, this.props.backdropTransitionInTiming);
    } // On modal open request, we slide the view up and fade in the backdrop


    if (this.props.isVisible && !prevProps.isVisible) {
      this.open();
    } else if (!this.props.isVisible && prevProps.isVisible) {
      // On modal close request, we slide the view down and fade out the backdrop
      this.close();
    }
  }

  render() {
    /* eslint-disable @typescript-eslint/no-unused-vars */
    const {
      animationIn,
      animationInTiming,
      animationOut,
      animationOutTiming,
      avoidKeyboard,
      coverScreen,
      hasBackdrop,
      backdropColor,
      backdropOpacity,
      backdropTransitionInTiming,
      backdropTransitionOutTiming,
      customBackdrop,
      children,
      isVisible,
      onModalShow,
      onBackButtonPress,
      useNativeDriver,
      propagateSwipe,
      style,
      ...otherProps
    } = this.props;
    const {
      testID,
      ...containerProps
    } = otherProps;
    const computedStyle = [{
      margin: this.getDeviceWidth() * 0.05,
      transform: [{
        translateY: 0
      }]
    }, styles.content, style];
    let panHandlers = {};
    let panPosition = {};

    if (this.state.isSwipeable) {
      var _this$panResponder;

      panHandlers = { ...((_this$panResponder = this.panResponder) === null || _this$panResponder === void 0 ? void 0 : _this$panResponder.panHandlers)
      };

      if (useNativeDriver) {
        var _this$state$pan4;

        panPosition = {
          transform: (_this$state$pan4 = this.state.pan) === null || _this$state$pan4 === void 0 ? void 0 : _this$state$pan4.getTranslateTransform()
        };
      } else {
        var _this$state$pan5;

        panPosition = (_this$state$pan5 = this.state.pan) === null || _this$state$pan5 === void 0 ? void 0 : _this$state$pan5.getLayout();
      }
    } // The user might decide not to show the modal while it is animating
    // to enhance performance.


    const _children = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? /*#__PURE__*/React.createElement(animatable.View, null) : children;

    const containerView = /*#__PURE__*/React.createElement(animatable.View, _extends({}, panHandlers, {
      ref: ref => this.contentRef = ref,
      style: [panPosition, computedStyle],
      pointerEvents: "box-none",
      useNativeDriver: useNativeDriver
    }, containerProps), _children); // If coverScreen is set to false by the user
    // we render the modal inside the parent view directly

    if (!coverScreen && this.state.isVisible) {
      return /*#__PURE__*/React.createElement(View, {
        pointerEvents: "box-none",
        style: [styles.backdrop, styles.containerBox]
      }, this.makeBackdrop(), containerView);
    }

    return /*#__PURE__*/React.createElement(Modal, _extends({
      transparent: true,
      animationType: "none",
      visible: this.state.isVisible,
      onRequestClose: onBackButtonPress
    }, otherProps), this.makeBackdrop(), avoidKeyboard ? /*#__PURE__*/React.createElement(KeyboardAvoidingView, {
      behavior: Platform.OS === "ios" ? "padding" : undefined,
      pointerEvents: "box-none",
      style: computedStyle.concat([{
        margin: 0
      }])
    }, containerView) : containerView);
  }

}

_defineProperty(ReactNativeModal, "defaultProps", {
  animationIn: "slideInUp",
  animationInTiming: 300,
  animationOut: "slideOutDown",
  animationOutTiming: 300,
  avoidKeyboard: false,
  coverScreen: true,
  hasBackdrop: true,
  backdropColor: "black",
  backdropOpacity: 0.7,
  backdropTransitionInTiming: 300,
  backdropTransitionOutTiming: 300,
  customBackdrop: null,
  useNativeDriver: false,
  deviceHeight: null,
  deviceWidth: null,
  hideModalContentWhileAnimating: false,
  propagateSwipe: false,
  isVisible: false,
  onModalShow: () => null,
  onModalWillShow: () => null,
  onModalHide: () => null,
  onModalWillHide: () => null,
  onBackdropPress: () => null,
  onBackButtonPress: () => null,
  swipeThreshold: 100,
  scrollTo: null,
  scrollOffset: 0,
  scrollOffsetMax: 0,
  scrollHorizontal: false,
  supportedOrientations: ["portrait", "landscape"]
});

export default ReactNativeModal;
//# sourceMappingURL=modal.js.map