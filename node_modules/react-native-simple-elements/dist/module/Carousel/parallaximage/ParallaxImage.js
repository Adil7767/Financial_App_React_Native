function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _templateObject2() {
  const data = _taggedTemplateLiteral(["\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    align-items: center;\n    justify-content: center;\n"]);

  _templateObject2 = function () {
    return data;
  };

  return data;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n    overflow: hidden;\n    align-items: center;\n    justify-content: center;\n"]);

  _templateObject = function () {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

// Parallax effect inspired by https://github.com/oblador/react-native-parallax/
import * as React from "react";
import { Animated, Easing, ActivityIndicator, findNodeHandle } from "react-native";
import styled from "styled-components/native";
const ParallaxContainer = styled.View(_templateObject());
const ParallaxLoaderContainer = styled.View(_templateObject2());
export default class ParallaxImage extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      offset: 0,
      width: 0,
      height: 0,
      status: 1,
      // 1 -> loading; 2 -> loaded // 3 -> transition finished; 4 -> error
      animOpacity: new Animated.Value(0)
    });

    _defineProperty(this, "_container", void 0);

    _defineProperty(this, "_mounted", void 0);

    this._onLoad = this._onLoad.bind(this);
    this._onError = this._onError.bind(this);
    this._measureLayout = this._measureLayout.bind(this);
  }

  setNativeProps(nativeProps) {
    this._container.setNativeProps(nativeProps);
  }

  componentDidMount() {
    this._mounted = true;
    setTimeout(() => {
      this._measureLayout();
    }, 0);
  }

  componentWillUnmount() {
    this._mounted = false;
  }

  _measureLayout() {
    if (this._container) {
      const {
        dimensions,
        vertical,
        carouselRef,
        sliderWidth,
        sliderHeight,
        itemWidth,
        itemHeight
      } = this.props;

      if (carouselRef) {
        this._container.measureLayout( // @ts-ignore
        findNodeHandle(carouselRef), (x, y, width, height, pageX, pageY) => {
          const offset = vertical ? y - (sliderHeight - itemHeight) / 2 : x - (sliderWidth - itemWidth) / 2;
          this.setState({
            offset: offset,
            width: dimensions && dimensions.width ? dimensions.width : Math.ceil(width),
            height: dimensions && dimensions.height ? dimensions.height : Math.ceil(height)
          });
        });
      }
    }
  }

  _onLoad(event) {
    const {
      animOpacity
    } = this.state;
    const {
      fadeDuration,
      onLoad
    } = this.props;

    if (!this._mounted) {
      return;
    }

    this.setState({
      status: 2
    });

    if (onLoad) {
      onLoad(event);
    }

    Animated.timing(animOpacity, {
      toValue: 1,
      duration: fadeDuration,
      easing: Easing.out(Easing.quad),
      isInteraction: false,
      useNativeDriver: true
    }).start(() => {
      this.setState({
        status: 3
      });
    });
  } // If arg is missing from method signature, it just won't be called


  _onError(event) {
    const {
      onError
    } = this.props;
    this.setState({
      status: 4
    });

    if (onError) {
      onError(event);
    }
  }

  get image() {
    const {
      status,
      animOpacity,
      offset,
      width,
      height
    } = this.state;
    const {
      scrollPosition,
      vertical,
      sliderWidth,
      sliderHeight,
      parallaxFactor,
      AnimatedImageComponent,
      ...other
    } = this.props;
    const parallaxPadding = (vertical ? height : width) * parallaxFactor;
    const requiredStyles = {
      position: "relative"
    };
    const dynamicStyles = {
      width: vertical ? width : width + parallaxPadding * 2,
      height: vertical ? height + parallaxPadding * 2 : height,
      opacity: animOpacity,
      transform: scrollPosition ? [{
        translateX: !vertical // @ts-ignore
        ? scrollPosition.interpolate({
          inputRange: [offset - sliderWidth, offset + sliderWidth],
          outputRange: [-parallaxPadding, parallaxPadding],
          extrapolate: "clamp"
        }) : 0
      }, {
        translateY: vertical // @ts-ignore
        ? scrollPosition.interpolate({
          inputRange: [offset - sliderHeight, offset + sliderHeight],
          outputRange: [-parallaxPadding, parallaxPadding],
          extrapolate: "clamp"
        }) : 0
      }] : []
    };
    return (
      /*#__PURE__*/
      // @ts-ignore
      React.createElement(AnimatedImageComponent, _extends({}, other, {
        style: [{
          position: "relative",
          resizeMode: "cover",
          width: null,
          height: null
        }, requiredStyles, dynamicStyles],
        onLoad: this._onLoad,
        onError: status !== 3 ? this._onError : undefined // prevent infinite-loop bug

      }))
    );
  }

  get spinner() {
    const {
      status
    } = this.state;
    const {
      showSpinner,
      spinnerColor
    } = this.props;
    return status === 1 && showSpinner ? /*#__PURE__*/React.createElement(ParallaxLoaderContainer, null, /*#__PURE__*/React.createElement(ActivityIndicator, {
      size: "small",
      color: spinnerColor,
      animating: true
    })) : false;
  }

  render() {
    return /*#__PURE__*/React.createElement(ParallaxContainer, {
      ref: c => {
        this._container = c;
      },
      pointerEvents: "none",
      onLayout: this._measureLayout
    }, this.image, this.spinner);
  }

}

_defineProperty(ParallaxImage, "defaultProps", {
  containerStyle: {},
  fadeDuration: 500,
  parallaxFactor: 0.3,
  showSpinner: true,
  spinnerColor: "rgba(0, 0, 0, 0.4)",
  AnimatedImageComponent: Animated.Image
});
//# sourceMappingURL=ParallaxImage.js.map