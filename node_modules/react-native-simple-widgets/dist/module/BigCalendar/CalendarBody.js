function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import dayjs from "dayjs";
import * as React from "react";
import { Platform, ScrollView, StyleSheet, View } from "react-native";
import { u } from "./styles/commonStyles";
import { useNow } from "./hooks/useNow";
import { usePanResponder } from "./hooks/usePanResponder";
import { useTheme } from "./theme/ThemeContext";
import { getCountOfEventsAtEvent, getOrderOfEvent, getRelativeTopInDay, hours, isToday, typedMemo } from "./utils";
import { CalendarEvent } from "./CalendarEvent";
import { HourGuideCell } from "./HourGuideCell";
import { HourGuideColumn } from "./HourGuideColumn";
const styles = StyleSheet.create({
  nowIndicator: {
    position: "absolute",
    zIndex: 10000,
    height: 2,
    width: "100%"
  }
});

function _CalendarBody({
  containerHeight,
  cellHeight,
  dateRange,
  style,
  onPressCell,
  events,
  onPressEvent,
  eventCellStyle,
  ampm,
  showTime,
  scrollOffsetMinutes,
  onSwipeHorizontal,
  hideNowIndicator,
  overlapOffset,
  renderEvent
}) {
  const scrollView = React.useRef(null);
  const {
    now
  } = useNow(!hideNowIndicator);
  React.useEffect(() => {
    if (scrollView.current && scrollOffsetMinutes && Platform.OS !== "ios") {
      // We add delay here to work correct on React Native
      // see: https://stackoverflow.com/questions/33208477/react-native-android-scrollview-scrollto-not-working
      setTimeout(() => {
        if (scrollView && scrollView.current) {
          scrollView.current.scrollTo({
            y: cellHeight * scrollOffsetMinutes / 60,
            animated: false
          });
        }
      }, Platform.OS === "web" ? 0 : 10);
    }
  }, [scrollView, scrollOffsetMinutes, cellHeight]);
  const panResponder = usePanResponder({
    onSwipeHorizontal
  });

  const _onPressCell = React.useCallback(date => {
    onPressCell && onPressCell(date.toDate());
  }, [onPressCell]);

  const _renderMappedEvent = event => /*#__PURE__*/React.createElement(CalendarEvent, {
    key: "".concat(event.start).concat(event.title).concat(event.end),
    event: event,
    onPressEvent: onPressEvent,
    eventCellStyle: eventCellStyle,
    showTime: showTime,
    eventCount: getCountOfEventsAtEvent(event, events),
    eventOrder: getOrderOfEvent(event, events),
    overlapOffset: overlapOffset,
    renderEvent: renderEvent,
    ampm: ampm
  });

  const theme = useTheme();
  return /*#__PURE__*/React.createElement(ScrollView, _extends({
    style: [{
      height: containerHeight - cellHeight * 3
    }, style],
    ref: scrollView,
    scrollEventThrottle: 32
  }, Platform.OS !== "web" ? panResponder.panHandlers : {}, {
    showsVerticalScrollIndicator: false,
    nestedScrollEnabled: true,
    contentOffset: Platform.OS === "ios" ? {
      x: 0,
      y: scrollOffsetMinutes
    } : {
      x: 0,
      y: 0
    }
  }), /*#__PURE__*/React.createElement(View, _extends({
    style: [u["flex-1"], theme.isRTL ? u["flex-row-reverse"] : u["flex-row"]]
  }, Platform.OS === "web" ? panResponder.panHandlers : {}), /*#__PURE__*/React.createElement(View, {
    style: [u["z-20"], u["w-50"]]
  }, hours.map(hour => /*#__PURE__*/React.createElement(HourGuideColumn, {
    key: hour,
    cellHeight: cellHeight,
    hour: hour,
    ampm: ampm
  }))), dateRange.map(date => /*#__PURE__*/React.createElement(View, {
    style: [u["flex-1"], u["overflow-hidden"]],
    key: date.toString()
  }, hours.map(hour => /*#__PURE__*/React.createElement(HourGuideCell, {
    key: hour,
    cellHeight: cellHeight,
    date: date,
    hour: hour,
    onPress: _onPressCell
  })), events.filter(({
    start
  }) => dayjs(start).isBetween(date.startOf("day"), date.endOf("day"), null, "[)")).map(_renderMappedEvent), events.filter(({
    start,
    end
  }) => dayjs(start).isBefore(date.startOf("day")) && dayjs(end).isBetween(date.startOf("day"), date.endOf("day"), null, "[)")).map(event => ({ ...event,
    start: dayjs(event.end).startOf("day")
  })).map(_renderMappedEvent), events.filter(({
    start,
    end
  }) => dayjs(start).isBefore(date.startOf("day")) && dayjs(end).isAfter(date.endOf("day"))).map(event => ({ ...event,
    start: dayjs(event.end).startOf("day"),
    end: dayjs(event.end).endOf("day")
  })).map(_renderMappedEvent), isToday(date) && !hideNowIndicator && /*#__PURE__*/React.createElement(View, {
    style: [styles.nowIndicator, {
      backgroundColor: theme.palette.nowIndicator
    }, {
      top: "".concat(getRelativeTopInDay(now), "%")
    }]
  })))));
}

export const CalendarBody = typedMemo(_CalendarBody);
//# sourceMappingURL=CalendarBody.js.map