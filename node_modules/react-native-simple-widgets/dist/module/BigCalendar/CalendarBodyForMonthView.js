function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import calendarize from "calendarize";
import dayjs from "dayjs";
import * as React from "react";
import { Platform, Text, TouchableOpacity, View } from "react-native";
import { u } from "./styles/commonStyles";
import { useNow } from "./hooks/useNow";
import { usePanResponder } from "./hooks/usePanResponder";
import { useTheme } from "./theme/ThemeContext";
import { typedMemo } from "./utils";
import { CalendarEventForMonthView } from "./CalendarEventForMonthView";

function _CalendarBodyForMonthView({
  containerHeight,
  targetDate,
  style,
  onPressCell,
  events,
  onPressEvent,
  eventCellStyle,
  onSwipeHorizontal,
  hideNowIndicator,
  renderEvent,
  maxVisibleEventCount,
  weekStartsOn
}) {
  const {
    now
  } = useNow(!hideNowIndicator);
  const [calendarWidth, setCalendarWidth] = React.useState(0);
  const panResponder = usePanResponder({
    onSwipeHorizontal
  });
  const weeks = calendarize(targetDate.toDate(), weekStartsOn);
  const minCellHeight = containerHeight / 5 - 30;
  const theme = useTheme();
  return /*#__PURE__*/React.createElement(View, _extends({
    style: [{
      height: containerHeight
    }, u["flex-column"], u["flex-1"], u["border-b"], u["border-l"], u["border-r"], u["rounded"], {
      borderColor: theme.palette.gray["200"]
    }, style],
    onLayout: ({
      nativeEvent: {
        layout
      }
    }) => setCalendarWidth(layout.width)
  }, panResponder.panHandlers), weeks.map((week, i) => /*#__PURE__*/React.createElement(View, {
    key: i,
    style: [u["flex-1"], theme.isRTL ? u["flex-row-reverse"] : u["flex-row"], Platform.OS === "android" && style, // TODO: in Android, backgroundColor is not applied to child components
    {
      minHeight: minCellHeight
    }]
  }, week.map(d => d > 0 ? targetDate.date(d) : null).map((date, ii) => /*#__PURE__*/React.createElement(TouchableOpacity, {
    onPress: () => date && onPressCell && onPressCell(date.toDate()),
    style: [i > 0 && u["border-t"], theme.isRTL && ii > 0 && u["border-r"], !theme.isRTL && ii > 0 && u["border-l"], {
      borderColor: theme.palette.gray["200"]
    }, u["p-2"], u["flex-1"], u["flex-column"], {
      minHeight: minCellHeight
    }],
    key: ii
  }, /*#__PURE__*/React.createElement(Text, {
    style: [{
      textAlign: "center"
    }, theme.typography.sm, {
      color: (date === null || date === void 0 ? void 0 : date.format("YYYY-MM-DD")) === now.format("YYYY-MM-DD") ? theme.palette.primary.main : theme.palette.gray["800"]
    }]
  }, date && date.format("D")), date && events.sort((a, b) => {
    if (dayjs(a.start).isSame(b.start, "day")) {
      const aDuration = dayjs.duration(dayjs(a.end).diff(dayjs(a.start))).days();
      const bDuration = dayjs.duration(dayjs(b.end).diff(dayjs(b.start))).days();
      return bDuration - aDuration;
    }

    return a.start.getTime() - b.start.getTime();
  }).filter(({
    start,
    end
  }) => date.isBetween(dayjs(start).startOf("day"), dayjs(end).endOf("day"), null, "[)")).reduce((elements, event, index, events) => [...elements, index > maxVisibleEventCount ? null : index === maxVisibleEventCount ? /*#__PURE__*/React.createElement(Text, {
    key: index,
    style: {
      fontSize: 11,
      marginTop: 2,
      fontWeight: "bold"
    }
  }, events.length - maxVisibleEventCount, " More") : /*#__PURE__*/React.createElement(CalendarEventForMonthView, {
    key: index,
    event: event,
    eventCellStyle: eventCellStyle,
    onPressEvent: onPressEvent,
    renderEvent: renderEvent,
    date: date,
    dayOfTheWeek: ii,
    calendarWidth: calendarWidth,
    isRTL: theme.isRTL
  })], []))))));
}

export const CalendarBodyForMonthView = typedMemo(_CalendarBodyForMonthView);
//# sourceMappingURL=CalendarBodyForMonthView.js.map