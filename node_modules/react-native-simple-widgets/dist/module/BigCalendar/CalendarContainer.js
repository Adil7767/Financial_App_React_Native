function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import dayjs from "dayjs";
import * as React from "react";
import { MIN_HEIGHT } from "./styles/commonStyles";
import { useTheme } from "./theme/ThemeContext";
import { getDatesInMonth, getDatesInNextCustomDays, getDatesInNextOneDay, getDatesInNextThreeDays, getDatesInWeek, isAllDayEvent, modeToNum, typedMemo } from "./utils";
import { CalendarBody } from "./CalendarBody";
import { CalendarBodyForMonthView } from "./CalendarBodyForMonthView";
import { CalendarHeader } from "./CalendarHeader";
import { CalendarHeaderForMonthView } from "./CalendarHeaderForMonthView";

function _CalendarContainer({
  events,
  height,
  ampm = false,
  date,
  eventCellStyle,
  locale = "en",
  hideNowIndicator = false,
  mode = "week",
  overlapOffset,
  scrollOffsetMinutes = 0,
  showTime = true,
  headerContainerStyle = {},
  bodyContainerStyle = {},
  swipeEnabled = true,
  weekStartsOn = 0,
  onChangeDate,
  onPressCell,
  onPressDateHeader,
  onPressEvent,
  renderEvent,
  renderHeader: HeaderComponent = CalendarHeader,
  renderHeaderForMonthView: HeaderComponentForMonthView = CalendarHeaderForMonthView,
  weekEndsOn = 6,
  maxVisibleEventCount = 3
}) {
  const [targetDate, setTargetDate] = React.useState(dayjs(date));
  React.useEffect(() => {
    if (date) {
      setTargetDate(dayjs(date));
    }
  }, [date]);
  const allDayEvents = React.useMemo(() => events.filter(event => isAllDayEvent(event.start, event.end)), [events]);
  const daytimeEvents = React.useMemo(() => events.filter(event => !isAllDayEvent(event.start, event.end)), [events]);
  const dateRange = React.useMemo(() => {
    switch (mode) {
      case "month":
        return getDatesInMonth(targetDate, locale);

      case "week":
        return getDatesInWeek(targetDate, weekStartsOn, locale);

      case "3days":
        return getDatesInNextThreeDays(targetDate, locale);

      case "day":
        return getDatesInNextOneDay(targetDate, locale);

      case "custom":
        return getDatesInNextCustomDays(targetDate, weekStartsOn, weekEndsOn, locale);

      default:
        throw new Error("[react-native-big-calendar] The mode which you specified \"".concat(mode, "\" is not supported."));
    }
  }, [mode, targetDate, locale, weekEndsOn, weekStartsOn]);
  React.useEffect(() => {
    if (onChangeDate) {
      onChangeDate([dateRange[0].toDate(), dateRange.slice(-1)[0].toDate()]);
    }
  }, [dateRange, onChangeDate]);
  const cellHeight = React.useMemo(() => Math.max(height - 30, MIN_HEIGHT) / 24, [height]);
  const theme = useTheme();
  const onSwipeHorizontal = React.useCallback(direction => {
    if (!swipeEnabled) {
      return;
    }

    if (direction === "LEFT" && !theme.isRTL || direction === "RIGHT" && theme.isRTL) {
      setTargetDate(targetDate.add(modeToNum(mode, targetDate), "day"));
    } else {
      setTargetDate(targetDate.add(modeToNum(mode, targetDate) * -1, "day"));
    }
  }, [swipeEnabled, targetDate, mode, theme.isRTL]);
  const commonProps = {
    cellHeight,
    dateRange,
    mode
  };

  if (mode === "month") {
    const headerProps = {
      style: headerContainerStyle,
      locale: locale,
      weekStartsOn: weekStartsOn
    };
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(HeaderComponentForMonthView, headerProps), /*#__PURE__*/React.createElement(CalendarBodyForMonthView, _extends({}, commonProps, {
      style: bodyContainerStyle,
      containerHeight: height,
      events: daytimeEvents,
      eventCellStyle: eventCellStyle,
      weekStartsOn: weekStartsOn,
      hideNowIndicator: hideNowIndicator,
      onPressCell: onPressCell,
      onPressEvent: onPressEvent,
      onSwipeHorizontal: onSwipeHorizontal,
      renderEvent: renderEvent,
      targetDate: targetDate,
      maxVisibleEventCount: maxVisibleEventCount
    })));
  }

  const headerProps = { ...commonProps,
    style: headerContainerStyle,
    allDayEvents: allDayEvents,
    onPressDateHeader: onPressDateHeader
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(HeaderComponent, headerProps), /*#__PURE__*/React.createElement(CalendarBody, _extends({}, commonProps, {
    style: bodyContainerStyle,
    containerHeight: height,
    events: daytimeEvents,
    eventCellStyle: eventCellStyle,
    hideNowIndicator: hideNowIndicator,
    overlapOffset: overlapOffset,
    scrollOffsetMinutes: scrollOffsetMinutes,
    ampm: ampm,
    showTime: showTime,
    onPressCell: onPressCell,
    onPressEvent: onPressEvent,
    onSwipeHorizontal: onSwipeHorizontal,
    renderEvent: renderEvent
  })));
}

export const CalendarContainer = typedMemo(_CalendarContainer);
//# sourceMappingURL=CalendarContainer.js.map