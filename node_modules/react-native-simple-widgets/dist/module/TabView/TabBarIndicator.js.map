{"version":3,"sources":["TabBarIndicator.tsx"],"names":["React","Animated","Easing","StyleSheet","I18nManager","TabBarIndicator","Component","navigationState","layout","width","getTabWidth","props","isIndicatorShown","routes","every","_","i","timing","opacity","toValue","duration","easing","in","linear","useNativeDriver","start","Value","position","inputRange","map","outputRange","reduce","acc","translateX","interpolate","extrapolate","multiply","isRTL","componentDidMount","fadeInIndicator","componentDidUpdate","render","style","transform","length","getTranslateX","push","scaleX","styles","indicator","left","index","create","backgroundColor","bottom","right","height"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n    Animated,\n    Easing,\n    StyleSheet,\n    I18nManager,\n    StyleProp,\n    ViewStyle,\n} from \"react-native\";\n\nimport { Route, SceneRendererProps, NavigationState } from \"./types\";\n\nexport type GetTabWidth = (index: number) => number;\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  width: string | number;\n  style?: StyleProp<ViewStyle>;\n  getTabWidth: GetTabWidth;\n};\n\nexport default class TabBarIndicator<T extends Route> extends React.Component<\n  Props<T>\n> {\n    componentDidMount() {\n        this.fadeInIndicator();\n    }\n\n    componentDidUpdate() {\n        this.fadeInIndicator();\n    }\n\n  private fadeInIndicator = () => {\n      const { navigationState, layout, width, getTabWidth } = this.props;\n\n      if (\n          !this.isIndicatorShown &&\n      width === \"auto\" &&\n      layout.width &&\n      // We should fade-in the indicator when we have widths for all the tab items\n      navigationState.routes.every((_, i) => getTabWidth(i))\n      ) {\n          this.isIndicatorShown = true;\n\n          Animated.timing(this.opacity, {\n              toValue: 1,\n              duration: 150,\n              easing: Easing.in(Easing.linear),\n              useNativeDriver: true,\n          }).start();\n      }\n  };\n\n  private isIndicatorShown = false;\n\n  private opacity = new Animated.Value(this.props.width === \"auto\" ? 0 : 1);\n\n  private getTranslateX = (\n      position: Animated.AnimatedInterpolation,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n  ) => {\n      const inputRange = routes.map((_, i) => i);\n\n      // every index contains widths at all previous indices\n      const outputRange = routes.reduce<number[]>((acc, _, i) => {\n          if (i === 0) return [0];\n          return [...acc, acc[i - 1] + getTabWidth(i - 1)];\n      }, []);\n\n      const translateX = position.interpolate({\n          inputRange,\n          outputRange,\n          extrapolate: \"clamp\",\n      });\n\n      return Animated.multiply(translateX, I18nManager.isRTL ? -1 : 1);\n  };\n\n  render() {\n      const {\n          position,\n          navigationState,\n          getTabWidth,\n          width,\n          style,\n          layout,\n      } = this.props;\n      const { routes } = navigationState;\n\n      const transform = [];\n\n      if (layout.width) {\n          const translateX =\n        routes.length > 1\n            ? this.getTranslateX(position, routes, getTabWidth)\n            : 0;\n\n          transform.push({ translateX });\n      }\n\n      if (width === \"auto\") {\n          const inputRange = routes.map((_, i) => i);\n          const outputRange = inputRange.map(getTabWidth);\n\n          transform.push(\n              {\n                  scaleX:\n            routes.length > 1\n                ? position.interpolate({\n                    inputRange,\n                    outputRange,\n                    extrapolate: \"clamp\",\n                })\n                : outputRange[0],\n              },\n              { translateX: 0.5 }\n          );\n      }\n\n      return (\n          <Animated.View\n              style={[\n                  styles.indicator,\n                  { width: width === \"auto\" ? 1 : width },\n                  // If layout is not available, use `left` property for positioning the indicator\n                  // This avoids rendering delay until we are able to calculate translateX\n                  layout.width\n                      ? { left: 0 }\n                      : { left: `${(100 / routes.length) * navigationState.index}%` },\n                  { transform },\n                  width === \"auto\" ? { opacity: this.opacity } : null,\n                  style,\n              ]}\n          />\n      );\n  }\n}\n\nconst styles = StyleSheet.create({\n    indicator: {\n        backgroundColor: \"#ffeb3b\",\n        position: \"absolute\",\n        left: 0,\n        bottom: 0,\n        right: 0,\n        height: 2,\n    },\n});\n"]}