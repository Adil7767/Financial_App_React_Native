{"version":3,"sources":["MaskInput.tsx"],"names":["React","TextInput","formatWithMask","forwardRef","props","ref","mask","value","onChangeText","placeholderFillCharacter","obfuscationCharacter","showObfuscatedValue","selection","rest","maskArray","useMemo","formattedValueResult","text","maskHasObfuscation","find","maskItem","Array","isArray","isValueObfuscated","handleChangeText","useCallback","textToFormat","masked","length","slice","result","unmasked","obfuscated","defaultPlaceholder","map","maskChar","join","undefined","inputValue","start","end"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport TextInput from \"react-native-simple-elements/components/TextInput\";\nimport type { MaskInputProps } from \"./MaskInput.types\";\nimport formatWithMask from \"./formatWithMask\";\n\nexport default React.forwardRef(function (\n    props: MaskInputProps,\n    ref: React.Ref<TextInput>\n) {\n    const {\n        mask,\n        value,\n        onChangeText,\n        placeholderFillCharacter = \"_\",\n        obfuscationCharacter,\n        showObfuscatedValue,\n        selection,\n        ...rest\n    } = props;\n\n    const maskArray = React.useMemo(\n        () => (typeof mask === \"function\" ? mask(value) : mask),\n        [mask, value]\n    );\n\n    const formattedValueResult = React.useMemo(() => {\n        return formatWithMask({ text: value || \"\", mask, obfuscationCharacter });\n    }, [mask, obfuscationCharacter, value]);\n\n    const maskHasObfuscation = React.useMemo(\n        () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n        [maskArray]\n    );\n\n    const isValueObfuscated = React.useMemo(\n        () => !!maskHasObfuscation && !!showObfuscatedValue,\n        [maskHasObfuscation, showObfuscatedValue]\n    );\n\n    const handleChangeText = React.useCallback(\n        (text: string) => {\n            let textToFormat = text;\n\n            if (isValueObfuscated) {\n                textToFormat = formattedValueResult.masked || \"\";\n\n                if (textToFormat.length > text.length) {\n                    textToFormat = textToFormat.slice(0, -1);\n                } else if (textToFormat.length < text.length) {\n                    textToFormat = textToFormat + text[text.length - 1];\n                }\n            }\n\n            const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n            onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n        },\n        [\n            isValueObfuscated,\n            mask,\n            obfuscationCharacter,\n            onChangeText,\n            formattedValueResult.masked,\n        ]\n    );\n\n    const defaultPlaceholder = React.useMemo(() => {\n        if (maskArray) {\n            return maskArray\n                .map((maskChar) => {\n                    if (typeof maskChar === \"string\") {\n                        return maskChar;\n                    } else {\n                        return placeholderFillCharacter;\n                    }\n                })\n                .join(\"\");\n        } else {\n            return undefined;\n        }\n    }, [maskArray, placeholderFillCharacter]);\n\n    const inputValue = isValueObfuscated\n        ? formattedValueResult.obfuscated\n        : formattedValueResult.masked;\n\n    return (\n        // @ts-ignore\n        <TextInput\n            placeholder={defaultPlaceholder}\n            {...rest}\n            value={inputValue}\n            selection={\n                isValueObfuscated\n                    ? { start: inputValue.length, end: inputValue.length }\n                    : selection\n            }\n            onChangeText={handleChangeText}\n            // @ts-ignore\n            ref={ref}\n        />\n    );\n});\n"]}