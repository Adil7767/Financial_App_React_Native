{"version":3,"sources":["formatWithMask.ts"],"names":["localeCurrencyDecimalSeparator","createNumberMaskByLocale","formatWithMask","props","text","mask","obfuscationCharacter","masked","unmasked","obfuscated","maskArray","maskCharIndex","valueCharIndex","length","maskChar","valueChar","unmaskedValueChar","shouldObsfucateChar","Array","isArray","maskCharRegex","matchRegex","RegExp","test","formatWithMaskByLocale","locale","amount","decimalSeparator","prefix","separator","delimiter","precision"],"mappings":"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","sourcesContent":["import { localeCurrencyDecimalSeparator } from \"../utils/currencyformat\";\nimport { createNumberMaskByLocale } from \"./createNumberMask\";\nimport type { FormatWithMaskProps, FormatWithMaskResult } from \"./formatWithMask.types\";\n\nfunction formatWithMask(\n    props: FormatWithMaskProps\n): FormatWithMaskResult {\n    const { text, mask, obfuscationCharacter = \"*\" } = props;\n\n    // make sure it'll not break with null or undefined inputs\n    if (!text) return { masked: \"\", unmasked: \"\", obfuscated: \"\" };\n    if (!mask)\n        return {\n            masked: text || \"\",\n            unmasked: text || \"\",\n            obfuscated: text || \"\",\n        };\n\n    const maskArray = typeof mask === \"function\" ? mask(text) : mask;\n\n    let masked = \"\";\n    let obfuscated = \"\";\n    let unmasked = \"\";\n\n    let maskCharIndex = 0;\n    let valueCharIndex = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        // if mask is ended, break.\n        if (maskCharIndex === maskArray.length) {\n            break;\n        }\n\n        // if value is ended, break.\n        if (valueCharIndex === text.length) {\n            break;\n        }\n\n        const maskChar = maskArray[maskCharIndex];\n        const valueChar = text[valueCharIndex];\n\n        // value equals mask: add to masked result and advance on both mask and value indexes\n        if (maskChar === valueChar) {\n            masked += maskChar;\n            obfuscated += maskChar;\n\n            valueCharIndex += 1;\n            maskCharIndex += 1;\n            continue;\n        }\n\n        const unmaskedValueChar = text[valueCharIndex];\n\n        // it's a regex maskChar: let's advance on value index and validate the value within the regex\n        if (typeof maskChar === \"object\") {\n            // advance on value index\n            valueCharIndex += 1;\n\n            const shouldObsfucateChar = Array.isArray(maskChar);\n\n            const maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n\n            const matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n            // value match regex: add to masked and unmasked result and advance on mask index too\n            if (matchRegex) {\n                masked += valueChar;\n                obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n                unmasked += unmaskedValueChar;\n\n                maskCharIndex += 1;\n            }\n\n            continue;\n        } else {\n            // it's a fixed maskChar: add to maskedResult and advance on mask index\n            masked += maskChar;\n            obfuscated += maskChar;\n\n            maskCharIndex += 1;\n            continue;\n        }\n    }\n\n    return { masked, unmasked, obfuscated };\n}\n\nexport const formatWithMaskByLocale = (locale, amount) => {\n    const decimalSeparator = localeCurrencyDecimalSeparator(locale);\n\n    return formatWithMask({\n        text: amount,\n        mask: createNumberMaskByLocale({\n            prefix: [],\n            separator: decimalSeparator,\n            delimiter: decimalSeparator === \",\" ? \".\" : \",\",\n            precision: decimalSeparator === \",\" ? 0 : 2,\n        }),\n    });\n};\n\nexport default formatWithMask;\n"]}