"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwiperFlatList = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _Pagination = require("../Pagination/Pagination");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MILLISECONDS = 1000;
const FIRST_INDEX = 0;
const ITEM_VISIBLE_PERCENT_THRESHOLD = 60; // TODO: figure out how to use forwardRef with generics

const {
  width: WIDTH,
  height: HEIGHT
} = _reactNative.Dimensions.get("window"); // const SwiperFlatList = React.forwardRef<RefProps, SwiperFlatListProps<SwiperType>>(


const SwiperFlatList = /*#__PURE__*/_react.default.forwardRef( // <T1 extends any>(
({
  vertical = false,
  children,
  data = [],
  renderItem,
  renderAll = false,
  index = FIRST_INDEX,
  // Pagination
  showPagination = false,
  PaginationComponent = _Pagination.Pagination,
  paginationActiveColor,
  paginationDefaultColor,
  paginationStyle,
  paginationStyleItem,
  paginationStyleItemActive,
  paginationStyleItemInactive,
  onPaginationSelectedIndex,
  // Autoplay
  autoplayDelay = 3,
  autoplay = false,
  autoplayLoop = false,
  autoplayLoopKeepAnimation = false,
  autoplayInvertDirection = false,
  // Functions
  onChangeIndex,
  onMomentumScrollEnd,
  onViewableItemsChanged,
  viewabilityConfig = {},
  disableGesture = false,
  e2eID,
  ...props
}, ref) => {
  let _data = [];

  let _renderItem;

  if (children) {
    // github.com/gusgard/react-native-swiper-flatlist/issues/40
    _data = Array.isArray(children) ? children : [children];

    _renderItem = ({
      item
    }) => item;
  } else if (data) {
    _data = data;
    _renderItem = renderItem;
  } else {
    console.error("Invalid props, `data` or `children` is required");
  }

  const size = _data.length; // Items to render in the initial batch.

  const _initialNumToRender = renderAll ? size : 1;

  const [currentIndexes, setCurrentIndexes] = _react.default.useState({
    index,
    prevIndex: index
  });

  const [ignoreOnMomentumScrollEnd, setIgnoreOnMomentumScrollEnd] = _react.default.useState(false);

  const flatListElement = _react.default.useRef(null);

  const [scrollEnabled, setScrollEnabled] = _react.default.useState(!disableGesture);

  const _onChangeIndex = _react.default.useCallback(({
    index: _index,
    prevIndex: _prevIndex
  }) => {
    if (_index !== _prevIndex) {
      onChangeIndex === null || onChangeIndex === void 0 ? void 0 : onChangeIndex({
        index: _index,
        prevIndex: _prevIndex
      });
    }
  }, [onChangeIndex]);

  const _scrollToIndex = (params, extra) => {
    var _flatListElement$curr;

    const {
      index: indexToScroll,
      animated = true
    } = params;
    const newParams = {
      animated,
      index: indexToScroll
    };
    setIgnoreOnMomentumScrollEnd(true);
    const next = {
      index: indexToScroll,
      prevIndex: currentIndexes.index
    };

    if (currentIndexes.index !== next.index && currentIndexes.prevIndex !== next.prevIndex) {
      setCurrentIndexes({
        index: next.index,
        prevIndex: next.prevIndex
      });
    } else if (currentIndexes.index !== next.index) {
      setCurrentIndexes(prevState => ({ ...prevState,
        index: next.index
      }));
    } else if (currentIndexes.prevIndex !== next.prevIndex) {
      setCurrentIndexes(prevState => ({ ...prevState,
        prevIndex: next.prevIndex
      }));
    }

    if (extra.useOnChangeIndex) {
      _onChangeIndex({
        index: next.index,
        prevIndex: next.prevIndex
      });
    } // When execute "scrollToIndex", we ignore the method "onMomentumScrollEnd"
    // because it not working on Android
    // https://github.com/facebook/react-native/issues/21718


    flatListElement === null || flatListElement === void 0 ? void 0 : (_flatListElement$curr = flatListElement.current) === null || _flatListElement$curr === void 0 ? void 0 : _flatListElement$curr.scrollToIndex(newParams);
  }; // change the index when the user swipe the items


  _react.default.useEffect(() => {
    _onChangeIndex({
      index: currentIndexes.index,
      prevIndex: currentIndexes.prevIndex
    });
  }, [currentIndexes.index]);

  _react.default.useImperativeHandle(ref, () => ({
    scrollToIndex: item => {
      setScrollEnabled(true);

      _scrollToIndex(item, {
        useOnChangeIndex: true
      });

      setScrollEnabled(!disableGesture);
    },
    getCurrentIndex: () => currentIndexes.index,
    getPrevIndex: () => currentIndexes.prevIndex,
    goToLastIndex: () => {
      setScrollEnabled(true);

      _scrollToIndex({
        index: size - 1
      }, {
        useOnChangeIndex: false
      });

      setScrollEnabled(!disableGesture);
    },
    goToFirstIndex: () => {
      setScrollEnabled(true);

      _scrollToIndex({
        index: FIRST_INDEX
      }, {
        useOnChangeIndex: false
      });

      setScrollEnabled(!disableGesture);
    }
  }));

  _react.default.useEffect(() => {
    const isLastIndexEnd = autoplayInvertDirection ? currentIndexes.index === FIRST_INDEX : currentIndexes.index === _data.length - 1;
    const shouldContinuoWithAutoplay = autoplay && !isLastIndexEnd;
    let autoplayTimer;

    if (shouldContinuoWithAutoplay || autoplayLoop) {
      autoplayTimer = setTimeout(() => {
        if (_data.length < 1) {
          // avoid nextIndex being set to NaN
          return;
        }

        const nextIncrement = autoplayInvertDirection ? -1 : +1;
        let nextIndex = (currentIndexes.index + nextIncrement) % _data.length;

        if (autoplayInvertDirection && nextIndex < FIRST_INDEX) {
          nextIndex = _data.length - 1;
        } // Disable end loop animation unless `autoplayLoopKeepAnimation` prop configured


        const animate = !isLastIndexEnd || autoplayLoopKeepAnimation;

        _scrollToIndex({
          index: nextIndex,
          animated: animate
        }, {
          useOnChangeIndex: true
        });
      }, autoplayDelay * MILLISECONDS);
    } // https://upmostly.com/tutorials/settimeout-in-react-components-using-hooks


    return () => clearTimeout(autoplayTimer);
  }, [currentIndexes.index]);

  const _onMomentumScrollEnd = event => {
    // NOTE: Method not executed when call "flatListElement?.current?.scrollToIndex"
    if (ignoreOnMomentumScrollEnd) {
      setIgnoreOnMomentumScrollEnd(false);
      return;
    }

    onMomentumScrollEnd === null || onMomentumScrollEnd === void 0 ? void 0 : onMomentumScrollEnd({
      index: currentIndexes.index
    }, event);
  };

  const _onViewableItemsChanged = _react.default.useMemo(() => params => {
    const {
      changed
    } = params;
    const newItem = changed === null || changed === void 0 ? void 0 : changed[FIRST_INDEX];

    if (newItem !== undefined) {
      const nextIndex = newItem.index;

      if (newItem.isViewable) {
        setCurrentIndexes(prevState => ({ ...prevState,
          index: nextIndex
        }));
      } else {
        setCurrentIndexes(prevState => ({ ...prevState,
          prevIndex: nextIndex
        }));
      }
    }

    onViewableItemsChanged === null || onViewableItemsChanged === void 0 ? void 0 : onViewableItemsChanged(params);
  }, []);

  const keyExtractor = (_item, _index) => _index.toString();

  const onScrollToIndexFailed = info => setTimeout(() => _scrollToIndex({
    index: info.index,
    animated: false
  }, {
    useOnChangeIndex: true
  }));

  const flatListProps = {
    scrollEnabled,
    ref: flatListElement,
    keyExtractor,
    horizontal: !vertical,
    showsHorizontalScrollIndicator: false,
    showsVerticalScrollIndicator: false,
    pagingEnabled: true,
    ...props,
    onMomentumScrollEnd: _onMomentumScrollEnd,
    onScrollToIndexFailed: onScrollToIndexFailed,
    data: _data,
    renderItem: _renderItem,
    initialNumToRender: _initialNumToRender,
    initialScrollIndex: index,
    // used with onScrollToIndexFailed
    viewabilityConfig: {
      // https://facebook.github.io/react-native/docs/flatlist#minimumviewtime
      minimumViewTime: 200,
      itemVisiblePercentThreshold: ITEM_VISIBLE_PERCENT_THRESHOLD,
      ...viewabilityConfig
    },
    onViewableItemsChanged: _onViewableItemsChanged,
    // debug: true, // for debug
    testID: e2eID
  };

  if (_reactNative.Platform.OS === "web") {
    if (props.getItemLayout === undefined) {
      // NOTE: should we pass height/width for getItemLayout?
      const ITEM_DIMENSION = vertical ? HEIGHT : WIDTH;

      flatListProps.getItemLayout = (__data, ItemIndex) => {
        return {
          length: ITEM_DIMENSION,
          offset: ITEM_DIMENSION * ItemIndex,
          index: ItemIndex
        };
      };
    }

    flatListProps.dataSet = {
      "paging-enabled-fix": true
    };
  }

  const scrollToIndexForPagination = params => {
    _scrollToIndex(params, {
      useOnChangeIndex: false
    });
  };

  const paginationProps = {
    size,
    paginationIndex: currentIndexes.index,
    scrollToIndex: scrollToIndexForPagination,
    paginationActiveColor,
    paginationDefaultColor,
    paginationStyle,
    paginationStyleItem,
    paginationStyleItemActive,
    paginationStyleItemInactive,
    onPaginationSelectedIndex,
    e2eID
  };
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_reactNative.FlatList, flatListProps), showPagination && /*#__PURE__*/_react.default.createElement(PaginationComponent, paginationProps));
}); // https://gist.github.com/Venryx/7cff24b17867da305fff12c6f8ef6f96


exports.SwiperFlatList = SwiperFlatList;
//# sourceMappingURL=SwiperFlatList.js.map