"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitCenterRect = fitCenterRect;
exports.transformedRect = transformedRect;
exports.getTransform = getTransform;
exports.alignedRect = alignedRect;
exports.availableTranslateSpace = availableTranslateSpace;
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function () {
    return _Rect.default;
  }
});
exports.Transform = void 0;

var _Rect = _interopRequireDefault(require("./Rect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Transform {
  constructor(scale, translateX, translateY, pivot) {
    _defineProperty(this, "scale", void 0);

    _defineProperty(this, "translateX", void 0);

    _defineProperty(this, "translateY", void 0);

    _defineProperty(this, "pivot", void 0);

    this.scale = scale;
    this.translateX = translateX;
    this.translateY = translateY;
    this.pivot = pivot;
  }

}

exports.Transform = Transform;

function isValidNumber(number) {
  if (typeof number === "number") {
    if (!isNaN(number)) {
      return true;
    }
  }

  return false;
}

function isValidRect(rect) {
  if (rect instanceof _Rect.default && rect.isValid()) {
    return true;
  }

  return false;
}

function isValidTransform(transform) {
  if (transform && isValidNumber(transform.scale) && isValidNumber(transform.translateX) && isValidNumber(transform.translateY)) {
    return true;
  }

  return false;
}

function fitCenterRect(contentAspectRatio, containerRect) {
  let w = containerRect.width();
  let h = containerRect.height();
  const viewAspectRatio = w / h;

  if (contentAspectRatio > viewAspectRatio) {
    h = w / contentAspectRatio;
  } else {
    w = h * contentAspectRatio;
  }

  return new _Rect.default(containerRect.centerX() - w / 2, containerRect.centerY() - h / 2, containerRect.centerX() + w / 2, containerRect.centerY() + h / 2);
}
/**
 * The React Native transform system use the center of the view as the pivot when scaling.
 * The translations are applied before scaling.
 * @param rect
 * @param transform
 * @returns {*}
 */


function transformedRect(rect, transform) {
  if (!isValidRect(rect)) {
    throw new Error("transformedRect...invalid rect");
  }

  if (!isValidTransform(transform)) {
    throw new Error("transformedRect...invalid transform");
  }

  const scale = transform.scale;
  const translateX = transform.translateX;
  const translateY = transform.translateY;
  const pivot = transform.pivot;

  if (pivot === undefined || pivot === null) {
    const width = rect.width() * scale;
    const height = rect.height() * scale;
    const centerX = rect.centerX() + translateX * scale;
    const centerY = rect.centerY() + translateY * scale;
    return new _Rect.default(centerX - width / 2, centerY - height / 2, centerX + width / 2, centerY + height / 2);
  } else {
    const pivotX = pivot.x;
    const pivotY = pivot.y;

    if (!isValidNumber(pivotX) || !isValidNumber(pivotY)) {
      throw new Error("transformedRect...invalid pivot x=" + pivot.x + ", y=" + pivot.y);
    } // first make the center still


    const resultRect = transformedRect(rect, {
      scale,
      translateX,
      translateY
    }); // the pivot moved during scaling, now move it back

    const dx = (scale - 1) * (pivotX - resultRect.centerX());
    const dy = (scale - 1) * (pivotY - resultRect.centerY());
    return resultRect.offset(-dx, -dy);
  }
}
/**
 * Calculate the transform from fromRect to toRect
 * @param fromRect
 * @param toRect
 * @returns {Transform}
 */


function getTransform(fromRect, toRect) {
  const scale = toRect.width() / fromRect.width();
  const translateX = (toRect.centerX() - fromRect.centerX()) / scale;
  const translateY = (toRect.centerY() - fromRect.centerY()) / scale;
  return new Transform(scale, translateX, translateY);
}
/**
 * Align edges of the rect with the viewport to avoid unnecessary blank space. NO scaling is performed here.
 * @param rect
 * @param viewPortRect
 * @returns {*|{line, column}|{column, line}|{x}}
 */


function alignedRect(rect, viewPortRect) {
  let dx = 0;
  let dy = 0;

  if (rect.width() > viewPortRect.width()) {
    if (rect.left > viewPortRect.left) {
      dx = viewPortRect.left - rect.left;
    } else if (rect.right < viewPortRect.right) {
      dx = viewPortRect.right - rect.right;
    }
  } else {
    dx = viewPortRect.centerX() - rect.centerX();
  }

  if (rect.height() > viewPortRect.height()) {
    if (rect.top > viewPortRect.top) {
      dy = viewPortRect.top - rect.top;
    } else if (rect.bottom < viewPortRect.bottom) {
      dy = viewPortRect.bottom - rect.bottom;
    }
  } else {
    dy = viewPortRect.centerY() - rect.centerY();
  }

  return rect.copy().offset(dx, dy);
}

function availableTranslateSpace(rect, viewPortRect) {
  return {
    left: viewPortRect.left - rect.left,
    right: rect.right - viewPortRect.right,
    top: viewPortRect.top - rect.top,
    bottom: rect.bottom - viewPortRect.bottom
  };
}
//# sourceMappingURL=TransformUtils.js.map