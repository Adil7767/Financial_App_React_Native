"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = _interopRequireWildcard(require("react-native"));

var _Scroller = _interopRequireDefault(require("../Scroller"));

var _GestureResponder = require("../GestureResponder");

var _TransformUtils = require("./TransformUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class ViewTransformer extends React.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      // transform state
      scale: 1,
      translateX: 0,
      translateY: 0,
      // animation state
      animator: new _reactNative.Animated.Value(0),
      // layout
      width: 0,
      height: 0,
      pageX: 0,
      pageY: 0
    });

    _defineProperty(this, "_viewPortRect", void 0);

    _defineProperty(this, "scroller", void 0);

    _defineProperty(this, "gestureResponder", void 0);

    _defineProperty(this, "innerViewRef", void 0);

    this._viewPortRect = new _TransformUtils.Rect(); // A holder to avoid new too much

    this.onLayout = this.onLayout.bind(this);
    this.cancelAnimation = this.cancelAnimation.bind(this);
    this.contentRect = this.contentRect.bind(this);
    this.transformedContentRect = this.transformedContentRect.bind(this);
    this.animate = this.animate.bind(this);
    this.onResponderGrant = this.onResponderGrant.bind(this);
    this.gestureResponder = (0, _GestureResponder.createResponder)({
      onStartShouldSetResponder: (evt, gestureState) => true,
      onMoveShouldSetResponderCapture: (evt, gestureState) => true,
      // onMoveShouldSetResponder: this.handleMove,
      onResponderMove: this.onResponderMove,
      onResponderGrant: this.onResponderGrant,
      onResponderRelease: this.onResponderRelease,
      onResponderTerminate: this.onResponderRelease,
      onResponderTerminationRequest: (evt, gestureState) => false,
      // Do not allow parent view to intercept gesture
      onResponderSingleTapConfirmed: (evt, gestureState) => {
        this.props.onSingleTapConfirmed && this.props.onSingleTapConfirmed();
      }
    });
    this.scroller = new _Scroller.default(true, (dx, dy, scroller) => {
      if (dx === 0 && dy === 0 && scroller.isFinished()) {
        this.animateBounce();
        return;
      }

      this.updateTransform({
        translateX: this.state.translateX + dx / this.state.scale,
        translateY: this.state.translateY + dy / this.state.scale
      });
    });
  }

  viewPortRect() {
    this._viewPortRect.set(0, 0, this.state.width, this.state.height);

    return this._viewPortRect;
  }

  contentRect() {
    let rect = this.viewPortRect().copy();

    if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {
      rect = (0, _TransformUtils.fitCenterRect)(this.props.contentAspectRatio, rect);
    }

    return rect;
  }

  transformedContentRect() {
    let rect = (0, _TransformUtils.transformedRect)(this.viewPortRect(), this.currentTransform());

    if (this.props.contentAspectRatio && this.props.contentAspectRatio > 0) {
      rect = (0, _TransformUtils.fitCenterRect)(this.props.contentAspectRatio, rect);
    }

    return rect;
  }

  currentTransform() {
    return new _TransformUtils.Transform(this.state.scale, this.state.translateX, this.state.translateY);
  }

  UNSAFE_componentWillMount() {// this.gestureResponder = createResponder({
    //     onStartShouldSetResponder: (evt, gestureState) => true,
    //     onMoveShouldSetResponderCapture: (evt, gestureState) => true,
    //     // onMoveShouldSetResponder: this.handleMove,
    //     onResponderMove: this.onResponderMove,
    //     onResponderGrant: this.onResponderGrant,
    //     onResponderRelease: this.onResponderRelease,
    //     onResponderTerminate: this.onResponderRelease,
    //     onResponderTerminationRequest: (evt, gestureState) => false, // Do not allow parent view to intercept gesture
    //     onResponderSingleTapConfirmed: (evt, gestureState) => {
    //         this.props.onSingleTapConfirmed && this.props.onSingleTapConfirmed();
    //     }
    // });
  }

  componentDidUpdate(prevProps, prevState) {
    this.props.onViewTransformed && this.props.onViewTransformed({
      scale: this.state.scale,
      translateX: this.state.translateX,
      translateY: this.state.translateY
    });
  }

  componentWillUnmount() {
    this.cancelAnimation();
  }

  render() {
    let gestureResponder = this.gestureResponder;

    if (!this.props.enableTransform) {
      gestureResponder = {};
    }

    return /*#__PURE__*/React.createElement(_reactNative.View, _extends({}, this.props, gestureResponder, {
      //   ref={'innerViewRef'}
      ref: el => {
        this.innerViewRef = el;
      },
      onLayout: this.onLayout
    }), /*#__PURE__*/React.createElement(_reactNative.View, {
      style: {
        flex: 1,
        transform: [{
          scale: this.state.scale
        }, {
          translateX: this.state.translateX
        }, {
          translateY: this.state.translateY
        }]
      }
    }, this.props.children));
  }

  onLayout(e) {
    const {
      width,
      height
    } = e.nativeEvent.layout;

    if (width !== this.state.width || height !== this.state.height) {
      this.setState({
        width,
        height
      });
    }

    this.measureLayout();
    this.props.onLayout && this.props.onLayout(e);
  }

  measureLayout() {
    // let handle = ReactNative.findNodeHandle(this.refs['innerViewRef']);
    const handle = _reactNative.default.findNodeHandle(this.innerViewRef);

    _reactNative.NativeModules.UIManager.measure(handle, (x, y, width, height, pageX, pageY) => {
      if (typeof pageX === "number" && typeof pageY === "number") {
        // avoid undefined values on Android devices
        if (this.state.pageX !== pageX || this.state.pageY !== pageY) {
          this.setState({
            pageX: pageX,
            pageY: pageY
          });
        }
      }
    });
  }

  onResponderGrant(evt, gestureState) {
    this.props.onTransformStart && this.props.onTransformStart();
    this.setState({
      responderGranted: true
    });
    this.measureLayout();
  }

  onResponderMove(evt, gestureState) {
    this.cancelAnimation();
    let dx = gestureState.moveX - gestureState.previousMoveX;
    let dy = gestureState.moveY - gestureState.previousMoveY;

    if (this.props.enableResistance) {
      const d = this.applyResistance(dx, dy);
      dx = d.dx;
      dy = d.dy;
    }

    if (!this.props.enableTranslate) {
      dx = dy = 0;
    }

    let transform = {};

    if (gestureState.previousPinch && gestureState.pinch && this.props.enableScale) {
      const scaleBy = gestureState.pinch / gestureState.previousPinch;
      const pivotX = gestureState.moveX - this.state.pageX;
      const pivotY = gestureState.moveY - this.state.pageY;
      const rect = (0, _TransformUtils.transformedRect)((0, _TransformUtils.transformedRect)(this.contentRect(), this.currentTransform()), new _TransformUtils.Transform(scaleBy, dx, dy, {
        x: pivotX,
        y: pivotY
      }));
      transform = (0, _TransformUtils.getTransform)(this.contentRect(), rect);
    } else {
      if (Math.abs(dx) > 2 * Math.abs(dy)) {
        dy = 0;
      } else if (Math.abs(dy) > 2 * Math.abs(dx)) {
        dx = 0;
      }

      transform.translateX = this.state.translateX + dx / this.state.scale;
      transform.translateY = this.state.translateY + dy / this.state.scale;
    }

    this.updateTransform(transform);
    return true;
  }

  onResponderRelease(evt, gestureState) {
    const handled = this.props.onTransformGestureReleased && this.props.onTransformGestureReleased({
      scale: this.state.scale,
      translateX: this.state.translateX,
      translateY: this.state.translateY
    });

    if (handled) {
      return;
    }

    if (gestureState.doubleTapUp) {
      if (!this.props.enableScale) {
        this.animateBounce();
        return;
      }

      let pivotX = 0;
      let pivotY = 0;

      if (gestureState.dx || gestureState.dy) {
        pivotX = gestureState.moveX - this.state.pageX;
        pivotY = gestureState.moveY - this.state.pageY;
      } else {
        pivotX = gestureState.x0 - this.state.pageX;
        pivotY = gestureState.y0 - this.state.pageY;
      }

      this.performDoubleTapUp(pivotX, pivotY);
    } else {
      if (this.props.enableTranslate) {
        this.performFling(gestureState.vx, gestureState.vy);
      } else {
        this.animateBounce();
      }
    }
  }

  performFling(vx, vy) {
    const startX = 0;
    const startY = 0;
    let maxX, minX, maxY, minY;
    const availablePanDistance = (0, _TransformUtils.availableTranslateSpace)(this.transformedContentRect(), this.viewPortRect());

    if (vx > 0) {
      minX = 0;

      if (availablePanDistance.left > 0) {
        maxX = availablePanDistance.left + this.props.maxOverScrollDistance;
      } else {
        maxX = 0;
      }
    } else {
      maxX = 0;

      if (availablePanDistance.right > 0) {
        minX = -availablePanDistance.right - this.props.maxOverScrollDistance;
      } else {
        minX = 0;
      }
    }

    if (vy > 0) {
      minY = 0;

      if (availablePanDistance.top > 0) {
        maxY = availablePanDistance.top + this.props.maxOverScrollDistance;
      } else {
        maxY = 0;
      }
    } else {
      maxY = 0;

      if (availablePanDistance.bottom > 0) {
        minY = -availablePanDistance.bottom - this.props.maxOverScrollDistance;
      } else {
        minY = 0;
      }
    }

    vx *= 1000; // per second

    vy *= 1000;

    if (Math.abs(vx) > 2 * Math.abs(vy)) {
      vy = 0;
    } else if (Math.abs(vy) > 2 * Math.abs(vx)) {
      vx = 0;
    }

    this.scroller.fling(startX, startY, vx, vy, minX, maxX, minY, maxY);
  }

  performDoubleTapUp(pivotX, pivotY) {
    const curScale = this.state.scale;
    let scaleBy;

    if (curScale > (1 + this.props.maxScale) / 2) {
      scaleBy = 1 / curScale;
    } else {
      scaleBy = this.props.maxScale / curScale;
    }

    let rect = (0, _TransformUtils.transformedRect)(this.transformedContentRect(), new _TransformUtils.Transform(scaleBy, 0, 0, {
      x: pivotX,
      y: pivotY
    }));
    rect = (0, _TransformUtils.transformedRect)(rect, new _TransformUtils.Transform(1, this.viewPortRect().centerX() - pivotX, this.viewPortRect().centerY() - pivotY));
    rect = (0, _TransformUtils.alignedRect)(rect, this.viewPortRect());
    this.animate(rect);
  }

  applyResistance(dx, dy) {
    const availablePanDistance = (0, _TransformUtils.availableTranslateSpace)(this.transformedContentRect(), this.viewPortRect());

    if (dx > 0 && availablePanDistance.left < 0 || dx < 0 && availablePanDistance.right < 0) {
      dx /= 3;
    }

    if (dy > 0 && availablePanDistance.top < 0 || dy < 0 && availablePanDistance.bottom < 0) {
      dy /= 3;
    }

    return {
      dx,
      dy
    };
  }

  cancelAnimation() {
    this.state.animator.stopAnimation();
  }

  animate(targetRect, durationInMillis) {
    let duration = 200;

    if (durationInMillis) {
      duration = durationInMillis;
    }

    const fromRect = this.transformedContentRect();

    if (fromRect.equals(targetRect, 0.01)) {
      return;
    }

    this.state.animator.removeAllListeners();
    this.state.animator.setValue(0);
    this.state.animator.addListener(state => {
      const progress = state.value;
      const left = fromRect.left + (targetRect.left - fromRect.left) * progress;
      const right = fromRect.right + (targetRect.right - fromRect.right) * progress;
      const top = fromRect.top + (targetRect.top - fromRect.top) * progress;
      const bottom = fromRect.bottom + (targetRect.bottom - fromRect.bottom) * progress;
      const transform = (0, _TransformUtils.getTransform)(this.contentRect(), new _TransformUtils.Rect(left, top, right, bottom));
      this.updateTransform(transform);
    });

    _reactNative.Animated.timing(this.state.animator, {
      toValue: 1,
      duration: duration,
      useNativeDriver: false,
      easing: _reactNative.Easing.inOut(_reactNative.Easing.ease)
    }).start();
  }

  animateBounce() {
    const curScale = this.state.scale;
    const minScale = 1;
    const maxScale = this.props.maxScale;
    let scaleBy = 1;

    if (curScale > maxScale) {
      scaleBy = maxScale / curScale;
    } else if (curScale < minScale) {
      scaleBy = minScale / curScale;
    }

    let rect = (0, _TransformUtils.transformedRect)(this.transformedContentRect(), new _TransformUtils.Transform(scaleBy, 0, 0, {
      x: this.viewPortRect().centerX(),
      y: this.viewPortRect().centerY()
    }));
    rect = (0, _TransformUtils.alignedRect)(rect, this.viewPortRect());
    this.animate(rect);
  }

  updateTransform(transform) {
    this.setState(transform);
  }

  forceUpdateTransform(transform) {
    this.setState(transform);
  }

  getAvailableTranslateSpace() {
    return (0, _TransformUtils.availableTranslateSpace)(this.transformedContentRect(), this.viewPortRect());
  }

}

exports.default = ViewTransformer;

_defineProperty(ViewTransformer, "Rect", _TransformUtils.Rect);

_defineProperty(ViewTransformer, "getTransform", _TransformUtils.getTransform);

_defineProperty(ViewTransformer, "defaultProps", {
  maxOverScrollDistance: 20,
  enableScale: true,
  enableTranslate: true,
  enableTransform: true,
  maxScale: 1,
  enableResistance: false
});
//# sourceMappingURL=index.js.map