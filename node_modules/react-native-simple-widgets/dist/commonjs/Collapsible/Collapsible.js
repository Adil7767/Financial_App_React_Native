"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _Accordion = _interopRequireDefault(require("./Accordion"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const ANIMATED_EASING_PREFIXES = ["easeInOut", "easeOut", "easeIn"];

class Collapsible extends React.Component {
  // easing
  constructor(props) {
    super(props);

    _defineProperty(this, "unmounted", void 0);

    _defineProperty(this, "_animation", void 0);

    _defineProperty(this, "contentHandle", null);

    _defineProperty(this, "_handleRef", ref => {
      this.contentHandle = ref;
    });

    _defineProperty(this, "_handleLayoutChange", event => {
      const contentHeight = event.nativeEvent.layout.height;

      if (this.state.animating || this.props.collapsed || this.state.measuring || this.state.contentHeight === contentHeight) {
        return;
      }

      this.state.height.setValue(contentHeight);
      this.setState({
        contentHeight
      });
    });

    this.state = {
      measuring: false,
      measured: false,
      height: new _reactNative.Animated.Value(props.collapsedHeight),
      contentHeight: 0,
      animating: false
    };
  }

  componentDidUpdate(prevProps) {
    if (prevProps.collapsed !== this.props.collapsed) {
      this.setState({
        measured: false
      }, () => this._componentDidUpdate(prevProps));
    } else {
      this._componentDidUpdate(prevProps);
    }
  }

  componentWillUnmount() {
    this.unmounted = true;
  }

  _componentDidUpdate(prevProps) {
    if (prevProps.collapsed !== this.props.collapsed) {
      this._toggleCollapsed(this.props.collapsed);
    } else if (this.props.collapsed && prevProps.collapsedHeight !== this.props.collapsedHeight) {
      this.state.height.setValue(this.props.collapsedHeight);
    }
  }

  _measureContent(callback) {
    this.setState({
      measuring: true
    }, () => {
      requestAnimationFrame(() => {
        if (!this.contentHandle) {
          this.setState({
            measuring: false
          }, () => callback(this.props.collapsedHeight));
        } else {
          let ref;

          if (typeof this.contentHandle.measure === "function") {
            ref = this.contentHandle;
          } else {
            ref = this.contentHandle.getNode();
          }

          ref.measure((x, y, width, height) => {
            this.setState({
              measuring: false,
              measured: true,
              contentHeight: height
            }, () => callback(height));
          });
        }
      });
    });
  }

  _toggleCollapsed(collapsed) {
    if (collapsed) {
      this._transitionToHeight(this.props.collapsedHeight);
    } else if (!this.contentHandle) {
      if (this.state.measured) {
        this._transitionToHeight(this.state.contentHeight);
      }

      return;
    } else {
      this._measureContent(contentHeight => {
        this._transitionToHeight(contentHeight);
      });
    }
  }

  _transitionToHeight(height) {
    const {
      duration
    } = this.props;
    const easing = this.props.easing;
    let formattedEasing;

    if (typeof easing === "string") {
      let prefix;
      let found = false;

      for (let i = 0; i < ANIMATED_EASING_PREFIXES.length; i++) {
        prefix = ANIMATED_EASING_PREFIXES[i];

        if (easing.substr(0, prefix.length) === prefix) {
          const temp = easing.substr(prefix.length, 1).toLowerCase() + easing.substr(prefix.length + 1);
          prefix = prefix.substr(4, 1).toLowerCase() + prefix.substr(5);
          formattedEasing = _reactNative.Easing[prefix](_reactNative.Easing[temp || "ease"]);
          found = true;
          break;
        }
      }

      if (!found) {
        formattedEasing = _reactNative.Easing[easing];
      }

      if (!easing) {
        throw new Error("Invalid easing type \"" + this.props.easing + "\"");
      }
    } // if (this._animation) {
    //     this._animation.stop();
    // }


    this.setState({
      animating: true
    }); // TODO: Animated.timing don't return anything, please check
    // this._animation = Animated.timing(this.state.height, {

    _reactNative.Animated.timing(this.state.height, {
      useNativeDriver: false,
      toValue: height ? height : 0,
      duration,
      easing: formattedEasing
    }).start(() => {
      if (this.unmounted) {
        return;
      }

      this.setState({
        animating: false
      }, () => {
        if (this.unmounted) {
          return;
        }

        this.props.onAnimationEnd();
      });
    });
  }

  render() {
    const {
      collapsed,
      enablePointerEvents,
      renderChildrenCollapsed
    } = this.props;
    const {
      height,
      contentHeight,
      measuring,
      measured,
      animating
    } = this.state;
    const hasKnownHeight = !measuring && (measured || collapsed);
    const style = hasKnownHeight && {
      overflow: "hidden",
      height: height
    };
    const contentStyle = {};

    if (measuring) {
      contentStyle.position = "absolute";
      contentStyle.opacity = 0;
    } else if (this.props.align === "center") {
      contentStyle.transform = [{
        translateY: height.interpolate({
          inputRange: [0, contentHeight],
          outputRange: [contentHeight / -2, 0]
        })
      }];
    } else if (this.props.align === "bottom") {
      contentStyle.transform = [{
        translateY: height.interpolate({
          inputRange: [0, contentHeight],
          outputRange: [-contentHeight, 0]
        })
      }];
    }

    if (animating) {
      contentStyle.height = contentHeight;
    }

    const shouldRenderChildren = renderChildrenCollapsed || (!collapsed || collapsed && animating) && (animating || measuring || measured);
    return /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
      style: style,
      pointerEvents: !enablePointerEvents && collapsed ? "none" : "auto"
    }, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
      ref: this._handleRef,
      style: [this.props.style, contentStyle],
      onLayout: this.state.animating ? undefined : this._handleLayoutChange
    }, shouldRenderChildren && this.props.children));
  }

}

_defineProperty(Collapsible, "defaultProps", {
  align: "top",
  collapsed: true,
  collapsedHeight: 0,
  enablePointerEvents: false,
  duration: 300,
  easing: "easeOutCubic",
  onAnimationEnd: () => null,
  renderChildrenCollapsed: true
});

_defineProperty(Collapsible, "Accordion", _Accordion.default);

var _default = Collapsible;
exports.default = _default;
//# sourceMappingURL=Collapsible.js.map