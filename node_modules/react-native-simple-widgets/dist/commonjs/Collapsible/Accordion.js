"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _Collapsible = _interopRequireDefault(require("./Collapsible"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const COLLAPSIBLE_PROPS = ["align", "collapsed", "collapsedHeight", "renderChildrenCollapsed", "enablePointerEvents", "duration", "easing", "style", "onAnimationEnd"];

class Accordion extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "_renderContainer", (section, key, renderCollapsible) => {
      const {
        activeSections,
        sectionContainerStyle,
        expandFromBottom,
        sections,
        underlayColor,
        touchableProps,
        touchableComponent: Touchable,
        renderHeader,
        renderFooter,
        renderSectionTitle
      } = this.props;
      return /*#__PURE__*/React.createElement(_reactNative.View, {
        key: key,
        style: sectionContainerStyle
      }, renderSectionTitle(section, key, activeSections.includes(key)), expandFromBottom && renderCollapsible(section, key), /*#__PURE__*/React.createElement(Touchable, _extends({
        onPress: () => this._toggleSection(key),
        underlayColor: underlayColor
      }, touchableProps, {
        accessibilityState: {
          expanded: activeSections.includes(key)
        }
      }), renderHeader(section, key, activeSections.includes(key), sections)), !expandFromBottom && renderCollapsible(section, key), renderFooter && renderFooter(section, key, activeSections.includes(key), sections));
    });
  }

  _toggleSection(section) {
    if (!this.props.disabled) {
      const {
        activeSections,
        expandMultiple,
        onChange
      } = this.props;
      let updatedSections = [];

      if (activeSections.includes(section)) {
        updatedSections = activeSections.filter(a => a !== section);
      } else if (expandMultiple) {
        updatedSections = [...activeSections, section];
      } else {
        updatedSections = [section];
      }

      if (onChange) {
        onChange(updatedSections);
      }
    }
  }

  render() {
    const {
      activeSections,
      // expandMultiple,
      // onChange,
      containerStyle,
      // sectionContainerStyle,
      // expandFromBottom,
      sections,
      // underlayColor,
      // touchableProps,
      // touchableComponent: Touchable,
      onAnimationEnd,
      renderContent,
      // renderHeader,
      // renderFooter,
      // renderSectionTitle,
      // disabled,
      renderAsFlatList,
      keyExtractor,
      ...restProps
    } = this.props;
    const viewProps = {};
    const collapsibleProps = {};
    Object.keys(restProps).forEach(key => {
      if (COLLAPSIBLE_PROPS.includes(key)) {
        collapsibleProps[key] = restProps[key];
      } else {
        viewProps[key] = restProps[key];
      }
    });

    const renderCollapsible = (section, key) => /*#__PURE__*/React.createElement(_Collapsible.default, _extends({
      collapsed: !activeSections.includes(key)
    }, collapsibleProps, {
      onAnimationEnd: () => onAnimationEnd(section, key)
    }), renderContent(section, key, activeSections.includes(key), sections));

    if (renderAsFlatList) {
      return /*#__PURE__*/React.createElement(_reactNative.FlatList, _extends({
        style: containerStyle,
        data: sections,
        extraData: activeSections,
        nestedScrollEnabled: true,
        keyExtractor: keyExtractor,
        renderItem: ({
          item,
          index
        }) => {
          const section = item;
          const key = keyExtractor(item, index);
          return this._renderContainer(section, key, renderCollapsible);
        }
      }, viewProps));
    }

    return /*#__PURE__*/React.createElement(_reactNative.View, _extends({
      style: containerStyle
    }, viewProps), sections.map((section, index) => {
      const key = keyExtractor(section, index);
      return this._renderContainer(section, key, renderCollapsible);
    }));
  }

}

_defineProperty(Accordion, "defaultProps", {
  underlayColor: "black",
  disabled: false,
  expandFromBottom: false,
  expandMultiple: false,
  touchableComponent: _reactNative.TouchableHighlight,
  keyExtractor: (item, index) => index,
  renderSectionTitle: () => null,
  onAnimationEnd: () => null,
  sectionContainerStyle: {},
  renderAsFlatList: false
});

var _default = Accordion;
exports.default = _default;
//# sourceMappingURL=Accordion.js.map