"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDatesInMonth = getDatesInMonth;
exports.getDatesInWeek = getDatesInWeek;
exports.getDatesInNextThreeDays = getDatesInNextThreeDays;
exports.getDatesInNextOneDay = getDatesInNextOneDay;
exports.formatHour = formatHour;
exports.isToday = isToday;
exports.getRelativeTopInDay = getRelativeTopInDay;
exports.todayInMinutes = todayInMinutes;
exports.modeToNum = modeToNum;
exports.formatStartEnd = formatStartEnd;
exports.isAllDayEvent = isAllDayEvent;
exports.getCountOfEventsAtEvent = getCountOfEventsAtEvent;
exports.getOrderOfEvent = getOrderOfEvent;
exports.getStyleForOverlappingEvent = getStyleForOverlappingEvent;
exports.getDatesInNextCustomDays = getDatesInNextCustomDays;
exports.getEventSpanningInfo = getEventSpanningInfo;
exports.hours = exports.DAY_MINUTES = exports.typedMemo = void 0;

var _dayjs = _interopRequireDefault(require("dayjs"));

var React = _interopRequireWildcard(require("react"));

var _commonStyles = require("./styles/commonStyles");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const typedMemo = React.memo;
exports.typedMemo = typedMemo;
const DAY_MINUTES = 1440;
exports.DAY_MINUTES = DAY_MINUTES;

function getDatesInMonth(date = new Date(), locale = "en") {
  const subject = (0, _dayjs.default)(date);
  const days = Array(subject.daysInMonth() - 1).fill(0).map((_, i) => {
    return subject.date(i + 1).locale(locale);
  });
  return days;
}

function getDatesInWeek(date = new Date(), weekStartsOn = 0, locale = "en") {
  const subject = (0, _dayjs.default)(date);
  const subjectDOW = subject.day();
  const days = Array(7).fill(0).map((_, i) => {
    return subject.add(i - (subjectDOW < weekStartsOn ? 7 + subjectDOW : subjectDOW) + weekStartsOn, "day").locale(locale);
  });
  return days;
}

function getDatesInNextThreeDays(date = new Date(), locale = "en") {
  const subject = (0, _dayjs.default)(date).locale(locale);
  const days = Array(3).fill(0).map((_, i) => {
    return subject.add(i, "day");
  });
  return days;
}

function getDatesInNextOneDay(date = new Date(), locale = "en") {
  const subject = (0, _dayjs.default)(date).locale(locale);
  const days = Array(1).fill(0).map((_, i) => {
    return subject.add(i, "day");
  });
  return days;
}

const hours = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
exports.hours = hours;

function formatHour(hour, ampm = false) {
  if (ampm) {
    if (hour === 0) {
      return "";
    }

    if (hour === 12) {
      return "12 PM";
    }

    if (hour > 12) {
      return "".concat(hour - 12, " PM");
    }

    return "".concat(hour, " AM");
  }

  return "".concat(hour, ":00");
}

function isToday(date) {
  const today = (0, _dayjs.default)();
  return today.isSame(date, "day");
}

function getRelativeTopInDay(date) {
  return 100 * (date.hour() * 60 + date.minute()) / DAY_MINUTES;
}

function todayInMinutes() {
  const today = (0, _dayjs.default)();
  return today.diff((0, _dayjs.default)().startOf("day"), "minute");
}

function modeToNum(mode, current) {
  if (mode === "month") {
    if (!current) {
      throw new Error("You must specify current date if mode is month");
    }

    if (current instanceof Date) {
      current = (0, _dayjs.default)(current);
    }

    return current.daysInMonth() - current.date() + 1;
  }

  switch (mode) {
    case "day":
      return 1;

    case "3days":
      return 3;

    case "week":
    case "custom":
      return 7;

    default:
      throw new Error("undefined mode");
  }
}

function formatStartEnd(start, end, format) {
  return "".concat((0, _dayjs.default)(start).format(format), " - ").concat((0, _dayjs.default)(end).format(format));
}

function isAllDayEvent(start, end) {
  const _start = (0, _dayjs.default)(start);

  const _end = (0, _dayjs.default)(end);

  return _start.hour() === 0 && _start.minute() === 0 && _end.hour() === 0 && _end.minute() === 0;
}

function getCountOfEventsAtEvent(event, eventList) {
  return eventList.filter(e => (0, _dayjs.default)(event.start).isBetween(e.start, e.end, "minute", "[)") || (0, _dayjs.default)(e.start).isBetween(event.start, event.end, "minute", "[)")).length;
}

function getOrderOfEvent(event, eventList) {
  const events = eventList.filter(e => (0, _dayjs.default)(event.start).isBetween(e.start, e.end, "minute", "[)") || (0, _dayjs.default)(e.start).isBetween(event.start, event.end, "minute", "[)")).sort((a, b) => {
    if ((0, _dayjs.default)(a.start).isSame(b.start)) {
      return (0, _dayjs.default)(a.start).diff(a.end) < (0, _dayjs.default)(b.start).diff(b.end) ? -1 : 1;
    } else {
      return (0, _dayjs.default)(a.start).isBefore(b.start) ? -1 : 1;
    }
  });
  const index = events.indexOf(event);
  return index === -1 ? 0 : index;
}

function getStyleForOverlappingEvent(eventPosition, overlapOffset, palettes) {
  let overlapStyle = {};
  const offset = overlapOffset;
  const start = eventPosition * offset;
  const zIndex = 100 + eventPosition;
  const bgColors = palettes.map(p => p.main);
  overlapStyle = {
    start: start + _commonStyles.OVERLAP_PADDING,
    end: _commonStyles.OVERLAP_PADDING,
    backgroundColor: bgColors[eventPosition % bgColors.length] || bgColors[0],
    zIndex
  };
  return overlapStyle;
}

function getDatesInNextCustomDays(date = new Date(), weekStartsOn = 0, weekEndsOn = 6, locale = "en") {
  const subject = (0, _dayjs.default)(date);
  const subjectDOW = subject.day();
  const days = Array(weekDaysCount(weekStartsOn, weekEndsOn)).fill(0).map((_, i) => {
    return subject.add(i - subjectDOW + weekStartsOn, "day").locale(locale);
  });
  return days;
} // TODO: This method should be unit-tested


function weekDaysCount(weekStartsOn, weekEndsOn) {
  // handle reverse week
  if (weekEndsOn < weekStartsOn) {
    let daysCount = 1;
    let i = weekStartsOn;

    while (i !== weekEndsOn) {
      ++i;
      ++daysCount;

      if (i > 6) {
        i = 0;
      } // fallback for infinite


      if (daysCount > 7) {
        break;
      }
    }

    return daysCount;
  } // normal week


  if (weekEndsOn > weekStartsOn) {
    return weekEndsOn - weekStartsOn + 1;
  } // default


  return 1;
}

function getEventSpanningInfo(event, date, dayOfTheWeek, calendarWidth) {
  const dayWidth = calendarWidth / 7; // adding + 1 because durations start at 0

  const eventDuration = _dayjs.default.duration((0, _dayjs.default)(event.end).diff((0, _dayjs.default)(event.start))).days() + 1;
  const eventDaysLeft = _dayjs.default.duration((0, _dayjs.default)(event.end).diff(date)).days() + 1;
  const weekDaysLeft = 7 - dayOfTheWeek;
  const isMultipleDays = eventDuration > 1; // This is to determine how many days from the event to show during a week

  const eventWeekDuration = eventDuration > weekDaysLeft ? weekDaysLeft : dayOfTheWeek === 0 && eventDaysLeft < eventDuration ? eventDaysLeft : eventDuration;
  const isMultipleDaysStart = isMultipleDays && (date.isSame(event.start, "day") || dayOfTheWeek === 0 && date.isAfter(event.start) || date.get("date") === 1); // - 6 to take in account the padding

  const eventWidth = dayWidth * eventWeekDuration - 6;
  return {
    eventWidth,
    isMultipleDays,
    isMultipleDaysStart,
    eventWeekDuration
  };
}
//# sourceMappingURL=utils.js.map