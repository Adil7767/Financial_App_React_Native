"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CalendarContainer = void 0;

var _dayjs = _interopRequireDefault(require("dayjs"));

var React = _interopRequireWildcard(require("react"));

var _commonStyles = require("./styles/commonStyles");

var _ThemeContext = require("./theme/ThemeContext");

var _utils = require("./utils");

var _CalendarBody = require("./CalendarBody");

var _CalendarBodyForMonthView = require("./CalendarBodyForMonthView");

var _CalendarHeader = require("./CalendarHeader");

var _CalendarHeaderForMonthView = require("./CalendarHeaderForMonthView");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _CalendarContainer({
  events,
  height,
  ampm = false,
  date,
  eventCellStyle,
  locale = "en",
  hideNowIndicator = false,
  mode = "week",
  overlapOffset,
  scrollOffsetMinutes = 0,
  showTime = true,
  headerContainerStyle = {},
  bodyContainerStyle = {},
  swipeEnabled = true,
  weekStartsOn = 0,
  onChangeDate,
  onPressCell,
  onPressDateHeader,
  onPressEvent,
  renderEvent,
  renderHeader: HeaderComponent = _CalendarHeader.CalendarHeader,
  renderHeaderForMonthView: HeaderComponentForMonthView = _CalendarHeaderForMonthView.CalendarHeaderForMonthView,
  weekEndsOn = 6,
  maxVisibleEventCount = 3
}) {
  const [targetDate, setTargetDate] = React.useState((0, _dayjs.default)(date));
  React.useEffect(() => {
    if (date) {
      setTargetDate((0, _dayjs.default)(date));
    }
  }, [date]);
  const allDayEvents = React.useMemo(() => events.filter(event => (0, _utils.isAllDayEvent)(event.start, event.end)), [events]);
  const daytimeEvents = React.useMemo(() => events.filter(event => !(0, _utils.isAllDayEvent)(event.start, event.end)), [events]);
  const dateRange = React.useMemo(() => {
    switch (mode) {
      case "month":
        return (0, _utils.getDatesInMonth)(targetDate, locale);

      case "week":
        return (0, _utils.getDatesInWeek)(targetDate, weekStartsOn, locale);

      case "3days":
        return (0, _utils.getDatesInNextThreeDays)(targetDate, locale);

      case "day":
        return (0, _utils.getDatesInNextOneDay)(targetDate, locale);

      case "custom":
        return (0, _utils.getDatesInNextCustomDays)(targetDate, weekStartsOn, weekEndsOn, locale);

      default:
        throw new Error("[react-native-big-calendar] The mode which you specified \"".concat(mode, "\" is not supported."));
    }
  }, [mode, targetDate, locale, weekEndsOn, weekStartsOn]);
  React.useEffect(() => {
    if (onChangeDate) {
      onChangeDate([dateRange[0].toDate(), dateRange.slice(-1)[0].toDate()]);
    }
  }, [dateRange, onChangeDate]);
  const cellHeight = React.useMemo(() => Math.max(height - 30, _commonStyles.MIN_HEIGHT) / 24, [height]);
  const theme = (0, _ThemeContext.useTheme)();
  const onSwipeHorizontal = React.useCallback(direction => {
    if (!swipeEnabled) {
      return;
    }

    if (direction === "LEFT" && !theme.isRTL || direction === "RIGHT" && theme.isRTL) {
      setTargetDate(targetDate.add((0, _utils.modeToNum)(mode, targetDate), "day"));
    } else {
      setTargetDate(targetDate.add((0, _utils.modeToNum)(mode, targetDate) * -1, "day"));
    }
  }, [swipeEnabled, targetDate, mode, theme.isRTL]);
  const commonProps = {
    cellHeight,
    dateRange,
    mode
  };

  if (mode === "month") {
    const headerProps = {
      style: headerContainerStyle,
      locale: locale,
      weekStartsOn: weekStartsOn
    };
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(HeaderComponentForMonthView, headerProps), /*#__PURE__*/React.createElement(_CalendarBodyForMonthView.CalendarBodyForMonthView, _extends({}, commonProps, {
      style: bodyContainerStyle,
      containerHeight: height,
      events: daytimeEvents,
      eventCellStyle: eventCellStyle,
      weekStartsOn: weekStartsOn,
      hideNowIndicator: hideNowIndicator,
      onPressCell: onPressCell,
      onPressEvent: onPressEvent,
      onSwipeHorizontal: onSwipeHorizontal,
      renderEvent: renderEvent,
      targetDate: targetDate,
      maxVisibleEventCount: maxVisibleEventCount
    })));
  }

  const headerProps = { ...commonProps,
    style: headerContainerStyle,
    allDayEvents: allDayEvents,
    onPressDateHeader: onPressDateHeader
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(HeaderComponent, headerProps), /*#__PURE__*/React.createElement(_CalendarBody.CalendarBody, _extends({}, commonProps, {
    style: bodyContainerStyle,
    containerHeight: height,
    events: daytimeEvents,
    eventCellStyle: eventCellStyle,
    hideNowIndicator: hideNowIndicator,
    overlapOffset: overlapOffset,
    scrollOffsetMinutes: scrollOffsetMinutes,
    ampm: ampm,
    showTime: showTime,
    onPressCell: onPressCell,
    onPressEvent: onPressEvent,
    onSwipeHorizontal: onSwipeHorizontal,
    renderEvent: renderEvent
  })));
}

const CalendarContainer = (0, _utils.typedMemo)(_CalendarContainer);
exports.CalendarContainer = CalendarContainer;
//# sourceMappingURL=CalendarContainer.js.map