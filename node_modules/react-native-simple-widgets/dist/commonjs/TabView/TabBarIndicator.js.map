{"version":3,"sources":["TabBarIndicator.tsx"],"names":["TabBarIndicator","React","Component","navigationState","layout","width","getTabWidth","props","isIndicatorShown","routes","every","_","i","Animated","timing","opacity","toValue","duration","easing","Easing","in","linear","useNativeDriver","start","Value","position","inputRange","map","outputRange","reduce","acc","translateX","interpolate","extrapolate","multiply","I18nManager","isRTL","componentDidMount","fadeInIndicator","componentDidUpdate","render","style","transform","length","getTranslateX","push","scaleX","styles","indicator","left","index","StyleSheet","create","backgroundColor","bottom","right","height"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n    Animated,\n    Easing,\n    StyleSheet,\n    I18nManager,\n    StyleProp,\n    ViewStyle,\n} from \"react-native\";\n\nimport { Route, SceneRendererProps, NavigationState } from \"./types\";\n\nexport type GetTabWidth = (index: number) => number;\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  width: string | number;\n  style?: StyleProp<ViewStyle>;\n  getTabWidth: GetTabWidth;\n};\n\nexport default class TabBarIndicator<T extends Route> extends React.Component<\n  Props<T>\n> {\n    componentDidMount() {\n        this.fadeInIndicator();\n    }\n\n    componentDidUpdate() {\n        this.fadeInIndicator();\n    }\n\n  private fadeInIndicator = () => {\n      const { navigationState, layout, width, getTabWidth } = this.props;\n\n      if (\n          !this.isIndicatorShown &&\n      width === \"auto\" &&\n      layout.width &&\n      // We should fade-in the indicator when we have widths for all the tab items\n      navigationState.routes.every((_, i) => getTabWidth(i))\n      ) {\n          this.isIndicatorShown = true;\n\n          Animated.timing(this.opacity, {\n              toValue: 1,\n              duration: 150,\n              easing: Easing.in(Easing.linear),\n              useNativeDriver: true,\n          }).start();\n      }\n  };\n\n  private isIndicatorShown = false;\n\n  private opacity = new Animated.Value(this.props.width === \"auto\" ? 0 : 1);\n\n  private getTranslateX = (\n      position: Animated.AnimatedInterpolation,\n      routes: Route[],\n      getTabWidth: GetTabWidth\n  ) => {\n      const inputRange = routes.map((_, i) => i);\n\n      // every index contains widths at all previous indices\n      const outputRange = routes.reduce<number[]>((acc, _, i) => {\n          if (i === 0) return [0];\n          return [...acc, acc[i - 1] + getTabWidth(i - 1)];\n      }, []);\n\n      const translateX = position.interpolate({\n          inputRange,\n          outputRange,\n          extrapolate: \"clamp\",\n      });\n\n      return Animated.multiply(translateX, I18nManager.isRTL ? -1 : 1);\n  };\n\n  render() {\n      const {\n          position,\n          navigationState,\n          getTabWidth,\n          width,\n          style,\n          layout,\n      } = this.props;\n      const { routes } = navigationState;\n\n      const transform = [];\n\n      if (layout.width) {\n          const translateX =\n        routes.length > 1\n            ? this.getTranslateX(position, routes, getTabWidth)\n            : 0;\n\n          transform.push({ translateX });\n      }\n\n      if (width === \"auto\") {\n          const inputRange = routes.map((_, i) => i);\n          const outputRange = inputRange.map(getTabWidth);\n\n          transform.push(\n              {\n                  scaleX:\n            routes.length > 1\n                ? position.interpolate({\n                    inputRange,\n                    outputRange,\n                    extrapolate: \"clamp\",\n                })\n                : outputRange[0],\n              },\n              { translateX: 0.5 }\n          );\n      }\n\n      return (\n          <Animated.View\n              style={[\n                  styles.indicator,\n                  { width: width === \"auto\" ? 1 : width },\n                  // If layout is not available, use `left` property for positioning the indicator\n                  // This avoids rendering delay until we are able to calculate translateX\n                  layout.width\n                      ? { left: 0 }\n                      : { left: `${(100 / routes.length) * navigationState.index}%` },\n                  { transform },\n                  width === \"auto\" ? { opacity: this.opacity } : null,\n                  style,\n              ]}\n          />\n      );\n  }\n}\n\nconst styles = StyleSheet.create({\n    indicator: {\n        backgroundColor: \"#ffeb3b\",\n        position: \"absolute\",\n        left: 0,\n        bottom: 0,\n        right: 0,\n        height: 2,\n    },\n});\n"]}