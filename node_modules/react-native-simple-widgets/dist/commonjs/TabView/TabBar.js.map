{"version":3,"sources":["TabBar.tsx"],"names":["TabBar","React","Component","layout","width","height","tabWidths","Animated","Value","createRef","style","tabStyle","StyleSheet","flatten","undefined","index","routes","scrollEnabled","flattenedWidth","key","endsWith","parseFloat","Number","isFinite","length","tabBarWidth","layoutWidth","props","state","navigationState","reduce","acc","_","i","getComputedTabWidth","getFlattenedTabWidth","value","getTabBarWidth","maxDistance","getMaxScrollDistance","scrollValue","Math","max","min","Platform","OS","I18nManager","isRTL","centerDistance","Array","from","total","tabWidth","scrollAmount","normalizeScrollValue","scrollViewRef","current","scrollTo","x","getScrollAmount","animated","e","nativeEvent","setState","maxScrollDistance","multiply","add","componentDidUpdate","prevProps","prevState","every","r","resetScroll","render","position","jumpTo","bounces","getAccessibilityLabel","getAccessible","getLabelText","getTestID","renderBadge","renderIcon","renderLabel","renderTabBarItem","activeColor","inactiveColor","pressColor","pressOpacity","onTabPress","onTabLongPress","labelStyle","indicatorStyle","contentContainerStyle","indicatorContainerStyle","isWidthDynamic","tabBarWidthPercent","translateX","getTranslateX","handleLayout","styles","tabBar","indicatorContainer","transform","renderIndicator","getTabWidth","scroll","tabContent","container","event","contentOffset","useNativeDriver","map","route","onLayout","measuredTabWidths","onPress","defaultPrevented","preventDefault","onLongPress","title","toUpperCase","accessible","accessibilityLabel","testID","create","flex","overflow","select","default","web","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","zIndex","flexDirection","flexWrap","top","left","right","bottom"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport {\n    Animated,\n    StyleSheet,\n    View,\n    ScrollView,\n    StyleProp,\n    ViewStyle,\n    TextStyle,\n    LayoutChangeEvent,\n    I18nManager,\n    Platform,\n} from \"react-native\";\nimport TabBarItem, { Props as TabBarItemProps } from \"./TabBarItem\";\nimport TabBarIndicator, { Props as IndicatorProps } from \"./TabBarIndicator\";\nimport {\n    Route,\n    Scene,\n    SceneRendererProps,\n    NavigationState,\n    Layout,\n    Event,\n} from \"./types\";\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  getLabelText: (scene: Scene<T>) => string | undefined;\n  getAccessible: (scene: Scene<T>) => boolean | undefined;\n  getAccessibilityLabel: (scene: Scene<T>) => string | undefined;\n  getTestID: (scene: Scene<T>) => string | undefined;\n  renderLabel?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderIcon?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderBadge?: (scene: Scene<T>) => React.ReactNode;\n  renderIndicator: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  labelStyle?: StyleProp<TextStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n};\n\ntype State = {\n  layout: Layout;\n  tabWidths: { [key: string]: number };\n};\n\nexport default class TabBar<T extends Route> extends React.Component<\n  Props<T>,\n  State\n> {\n  static defaultProps = {\n      getLabelText: ({ route }: Scene<Route>) =>\n          typeof route.title === \"string\" ? route.title.toUpperCase() : route.title,\n      getAccessible: ({ route }: Scene<Route>) =>\n          typeof route.accessible !== \"undefined\" ? route.accessible : true,\n      getAccessibilityLabel: ({ route }: Scene<Route>) =>\n          typeof route.accessibilityLabel === \"string\"\n              ? route.accessibilityLabel\n              : typeof route.title === \"string\"\n                  ? route.title\n                  : undefined,\n      getTestID: ({ route }: Scene<Route>) => route.testID,\n      renderIndicator: (props: IndicatorProps<Route>) => (\n          <TabBarIndicator {...props} />\n      ),\n  };\n\n  state: State = {\n      layout: { width: 0, height: 0 },\n      tabWidths: {},\n  };\n\n  componentDidUpdate(prevProps: Props<T>, prevState: State) {\n      const { navigationState } = this.props;\n      const { layout, tabWidths } = this.state;\n\n      if (\n          prevProps.navigationState.routes.length !==\n        navigationState.routes.length ||\n      prevProps.navigationState.index !== navigationState.index ||\n      prevState.layout.width !== layout.width ||\n      prevState.tabWidths !== tabWidths\n      ) {\n          if (\n              this.getFlattenedTabWidth(this.props.tabStyle) === \"auto\" &&\n        !(\n            layout.width &&\n          navigationState.routes.every(\n              (r) => typeof tabWidths[r.key] === \"number\"\n          )\n        )\n          ) {\n              // When tab width is dynamic, only adjust the scroll once we have all tab widths and layout\n              return;\n          }\n\n          this.resetScroll(navigationState.index);\n      }\n  }\n\n  // to store the layout.width of each tab\n  // when all onLayout's are fired, this would be set in state\n  private measuredTabWidths: { [key: string]: number } = {};\n\n  private scrollAmount = new Animated.Value(0);\n\n  private scrollViewRef = React.createRef<ScrollView>();\n\n  private getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n      const tabStyle = StyleSheet.flatten(style);\n\n      return tabStyle ? tabStyle.width : undefined;\n  };\n\n  private getComputedTabWidth = (\n      index: number,\n      layout: Layout,\n      routes: Route[],\n      scrollEnabled: boolean | undefined,\n      tabWidths: { [key: string]: number },\n      flattenedWidth: string | number | undefined\n  ) => {\n      if (flattenedWidth === \"auto\") {\n          return tabWidths[routes[index].key] || 0;\n      }\n\n      switch (typeof flattenedWidth) {\n      case \"number\":\n          return flattenedWidth;\n      case \"string\":\n          if (flattenedWidth.endsWith(\"%\")) {\n              const width = parseFloat(flattenedWidth);\n              if (Number.isFinite(width)) {\n                  return layout.width * (width / 100);\n              }\n          }\n      }\n\n      if (scrollEnabled) {\n          return (layout.width / 5) * 2;\n      }\n\n      return layout.width / routes.length;\n  };\n\n  private getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n      tabBarWidth - layoutWidth;\n\n  private getTabBarWidth = (props: Props<T>, state: State) => {\n      const { layout, tabWidths } = state;\n      const { scrollEnabled, tabStyle } = props;\n      const { routes } = props.navigationState;\n\n      return routes.reduce<number>(\n          (acc, _, i) =>\n              acc +\n        this.getComputedTabWidth(\n            i,\n            layout,\n            routes,\n            scrollEnabled,\n            tabWidths,\n            this.getFlattenedTabWidth(tabStyle)\n        ),\n          0\n      );\n  };\n\n  private normalizeScrollValue = (\n      props: Props<T>,\n      state: State,\n      value: number\n  ) => {\n      const { layout } = state;\n      const tabBarWidth = this.getTabBarWidth(props, state);\n      const maxDistance = this.getMaxScrollDistance(tabBarWidth, layout.width);\n      const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n      if (Platform.OS === \"android\" && I18nManager.isRTL) {\n      // On Android, scroll value is not applied in reverse in RTL\n      // so we need to manually adjust it to apply correct value\n          return maxDistance - scrollValue;\n      }\n\n      return scrollValue;\n  };\n\n  private getScrollAmount = (props: Props<T>, state: State, index: number) => {\n      const { layout, tabWidths } = state;\n      const { scrollEnabled, tabStyle } = props;\n      const { routes } = props.navigationState;\n\n      const centerDistance = Array.from({ length: index + 1 }).reduce<number>(\n          (total, _, i) => {\n              const tabWidth = this.getComputedTabWidth(\n                  i,\n                  layout,\n                  routes,\n                  scrollEnabled,\n                  tabWidths,\n                  this.getFlattenedTabWidth(tabStyle)\n              );\n\n              // To get the current index centered we adjust scroll amount by width of indexes\n              // 0 through (i - 1) and add half the width of current index i\n              return total + (index === i ? tabWidth / 2 : tabWidth);\n          },\n          0\n      );\n\n      const scrollAmount = centerDistance - layout.width / 2;\n\n      return this.normalizeScrollValue(props, state, scrollAmount);\n  };\n\n  private resetScroll = (index: number) => {\n      if (this.props.scrollEnabled) {\n          this.scrollViewRef.current?.scrollTo({\n              x: this.getScrollAmount(this.props, this.state, index),\n              animated: true,\n          });\n      }\n  };\n\n  private handleLayout = (e: LayoutChangeEvent) => {\n      const { height, width } = e.nativeEvent.layout;\n\n      if (\n          this.state.layout.width === width &&\n      this.state.layout.height === height\n      ) {\n          return;\n      }\n\n      this.setState({\n          layout: {\n              height,\n              width,\n          },\n      });\n  };\n\n  private getTranslateX = (\n      scrollAmount: Animated.Value,\n      maxScrollDistance: number\n  ) =>\n      Animated.multiply(\n          Platform.OS === \"android\" && I18nManager.isRTL\n              ? Animated.add(maxScrollDistance, Animated.multiply(scrollAmount, -1))\n              : scrollAmount,\n          I18nManager.isRTL ? 1 : -1\n      );\n\n  render() {\n      const {\n          position,\n          navigationState,\n          jumpTo,\n          scrollEnabled,\n          bounces,\n          getAccessibilityLabel,\n          getAccessible,\n          getLabelText,\n          getTestID,\n          renderBadge,\n          renderIcon,\n          renderLabel,\n          renderTabBarItem,\n          activeColor,\n          inactiveColor,\n          pressColor,\n          pressOpacity,\n          onTabPress,\n          onTabLongPress,\n          tabStyle,\n          labelStyle,\n          indicatorStyle,\n          contentContainerStyle,\n          style,\n          indicatorContainerStyle,\n      } = this.props;\n      const { layout, tabWidths } = this.state;\n      const { routes } = navigationState;\n\n      const isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === \"auto\";\n      const tabBarWidth = this.getTabBarWidth(this.props, this.state);\n      const tabBarWidthPercent = `${routes.length * 40}%`;\n      const translateX = this.getTranslateX(\n          this.scrollAmount,\n          this.getMaxScrollDistance(tabBarWidth, layout.width)\n      );\n\n      return (\n          <Animated.View\n              onLayout={this.handleLayout}\n              style={[styles.tabBar, style]}\n          >\n              <Animated.View\n                  pointerEvents=\"none\"\n                  style={[\n                      styles.indicatorContainer,\n                      scrollEnabled ? { transform: [{ translateX }] as any } : null,\n                      tabBarWidth\n                          ? { width: tabBarWidth }\n                          : scrollEnabled\n                              ? { width: tabBarWidthPercent }\n                              : null,\n                      indicatorContainerStyle,\n                  ]}\n              >\n                  {this.props.renderIndicator({\n                      position,\n                      layout,\n                      navigationState,\n                      jumpTo,\n                      width: isWidthDynamic ? \"auto\" : `${100 / routes.length}%`,\n                      style: indicatorStyle,\n                      getTabWidth: (i: number) =>\n                          this.getComputedTabWidth(\n                              i,\n                              layout,\n                              routes,\n                              scrollEnabled,\n                              tabWidths,\n                              this.getFlattenedTabWidth(tabStyle)\n                          ),\n                  })}\n              </Animated.View>\n              <View style={styles.scroll}>\n                  <Animated.ScrollView\n                      horizontal\n                      accessibilityRole=\"tablist\"\n                      keyboardShouldPersistTaps=\"handled\"\n                      scrollEnabled={scrollEnabled}\n                      bounces={bounces}\n                      alwaysBounceHorizontal={false}\n                      scrollsToTop={false}\n                      showsHorizontalScrollIndicator={false}\n                      automaticallyAdjustContentInsets={false}\n                      overScrollMode=\"never\"\n                      contentContainerStyle={[\n                          styles.tabContent,\n                          scrollEnabled\n                              ? { width: tabBarWidth || tabBarWidthPercent }\n                              : styles.container,\n                          contentContainerStyle,\n                      ]}\n                      scrollEventThrottle={16}\n                      onScroll={Animated.event(\n                          [\n                              {\n                                  nativeEvent: {\n                                      contentOffset: { x: this.scrollAmount },\n                                  },\n                              },\n                          ],\n                          { useNativeDriver: true }\n                      )}\n                      ref={this.scrollViewRef}\n                  >\n                      {routes.map((route: T) => {\n                          const props: TabBarItemProps<T> & { key: string } = {\n                              key: route.key,\n                              position: position,\n                              route: route,\n                              navigationState: navigationState,\n                              getAccessibilityLabel: getAccessibilityLabel,\n                              getAccessible: getAccessible,\n                              getLabelText: getLabelText,\n                              getTestID: getTestID,\n                              renderBadge: renderBadge,\n                              renderIcon: renderIcon,\n                              renderLabel: renderLabel,\n                              activeColor: activeColor,\n                              inactiveColor: inactiveColor,\n                              pressColor: pressColor,\n                              pressOpacity: pressOpacity,\n                              onLayout: isWidthDynamic\n                                  ? (e) => {\n                                      this.measuredTabWidths[route.key] =\n                        e.nativeEvent.layout.width;\n\n                                      // When we have measured widths for all of the tabs, we should updates the state\n                                      // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n                                      if (\n                                          routes.every(\n                                              (r) =>\n                                                  typeof this.measuredTabWidths[r.key] === \"number\"\n                                          )\n                                      ) {\n                                          this.setState({\n                                              tabWidths: { ...this.measuredTabWidths },\n                                          });\n                                      }\n                                  }\n                                  : undefined,\n                              onPress: () => {\n                                  const event: Scene<T> & Event = {\n                                      route,\n                                      defaultPrevented: false,\n                                      preventDefault: () => {\n                                          event.defaultPrevented = true;\n                                      },\n                                  };\n\n                                  onTabPress?.(event);\n\n                                  if (event.defaultPrevented) {\n                                      return;\n                                  }\n\n                                  this.props.jumpTo(route.key);\n                              },\n                              onLongPress: () => onTabLongPress?.({ route }),\n                              labelStyle: labelStyle,\n                              style: tabStyle,\n                          };\n\n                          return renderTabBarItem ? (\n                              renderTabBarItem(props)\n                          ) : (\n                              <TabBarItem {...props} />\n                          );\n                      })}\n                  </Animated.ScrollView>\n              </View>\n          </Animated.View>\n      );\n  }\n}\n\nconst styles = StyleSheet.create({\n    container: {\n        flex: 1,\n    },\n    scroll: {\n        overflow: Platform.select({ default: \"scroll\", web: undefined }),\n    },\n    tabBar: {\n        backgroundColor: \"#2196f3\",\n        elevation: 4,\n        shadowColor: \"black\",\n        shadowOpacity: 0.1,\n        shadowRadius: StyleSheet.hairlineWidth,\n        shadowOffset: {\n            height: StyleSheet.hairlineWidth,\n            width: 0,\n        },\n        zIndex: 1,\n    },\n    tabContent: {\n        flexDirection: \"row\",\n        flexWrap: \"nowrap\",\n    },\n    indicatorContainer: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    },\n});\n"]}